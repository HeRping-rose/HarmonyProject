# 十一、华为登录

# 1. 华为登录

 

![image.png](https://cdn.nlark.com/yuque/0/2024/png/639379/1718320142504-e11cc760-af33-4cbc-ad7e-21f267760cee.png?x-oss-process=image%2Fformat%2Cwebp)

除了常规的账号密码登录之外，我们还可以借助华为账号实现三方登录，Account Kit（华为帐号服务）提供简单、快速、安全的登录和授权功能，让用户无需输入帐号、密码和繁琐验证，避免因忘记密码而带来的麻烦，为您创建帐号并登录所有HarmonyOS应用，带来更高的注册转化，同时通过授权获得用户头像昵称、手机号码等信息，提升用户黏性。

## 1.1. 开发准备

当应用需要使用以下开放能力的一种或多种时，为正常调试运行应用，需要预先**添加公钥指纹**

- **Account Kit（华为帐号服务）**
- Call Kit（通话服务）
- Game Service Kit（游戏服务）
- Health Service Kit（运动健康服务）
- IAP Kit（应用内支付服务）
- Live View Kit（实况窗服务，当需要使用Push Kit时必须执行此步骤）
- **Map Kit（地图服务）**
- Payment Kit（华为支付服务）
- **Push Kit（推送服务）**
- Scan Kit（统一扫码服务）

### 1.1.1. 配置应用签名证书

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1718320177051-5ad4dc4b-e98d-434b-b7b7-0f4928d8e3f6.png)

### 1.1.2. 在DevEco Studio工具侧生成密钥（.p12）和证书请求文件（.csr）

在主菜单栏单击Build（构建）-> Generate Key and CSR（生成私钥和证书请求文件）

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713941303455-ac24fc42-714f-46af-8209-29a811e1b123.png)

选择要生成的文件目标位置并设置密码，填`Alias别名`以及`First and last name`之后，点击Next按钮

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713941617706-db44e1ba-243d-4f13-85ff-da2a8242673f.png)

出现下面的弹框之后，填写`CSR file`文件目标位置之后，点击Finish按钮完成CSR文件创建

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713941737396-f94fcf08-be27-44ab-90ab-dacbba5408b4.png)

检查本地目录中，是否成功生成`.csr` 和 `.p12` 文件

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713941820291-f92203c4-3ae0-4312-b98b-f6c118459bf4.png)

### 1.1.3. 申请调试证书

在AGC平台点击`用户与访问`, 左侧点击`证书管理`，再点击还右侧新增证书

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713950947849-2e64653f-bb8f-4d49-a11b-1172d47dc156.png)

在弹框中填写证书名称、选择证书类型为`调试证书`，选取我们在第一步生成的`·csr`文件，最后点击提交

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713951826129-a8fbfee5-2107-4da4-927a-ba8fb3b0004e.png)

会看到证书管理列表中多了一条记录

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713951785777-43b47513-c53c-4f4c-8b06-b3259b534432.png)

最后我们点击下载按钮，把调试证书下载的本地，后来配置要用

### 1.1.4. 申请调试profile

进入AGC平台，点击我的项目进入到项目页，点击左侧`HAP Provision Profile`，点击右侧的`添加`按钮

弹出框内选择上一步生成的meikou_pre调试证书

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713951618656-b19c6981-8742-4ca4-b37f-970785bb0bd9.png)

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1718323002129-90cb6b78-1340-41f4-bcba-e4eebecd8585.png)

点击下载按钮，把profile文件下载到本地

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713952003997-96ce7fcc-3f0c-4040-8b9c-215e196edd96.png)



### 1.1.5. DevEco Studio工具中配置签名信息

点击`文件->项目结构`

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713952147784-f74e4949-b819-43a2-a132-ed8ad80d0aa0.png)

点击“Signing Configs”页签。去除勾选的“Automatically generate signature”（如果是API 8和9工程，需同时勾选“Support HarmonyOS”），填写相关信息后，点击“OK”。

- **Store File：密钥库文件，选择****生成密钥和证书请求文件****时生成的.p12文件**
- Store Password：密钥库密码，需要与生成密钥和证书请求文件时设置的密钥库密码保持一致
- Key alias：密钥的别名信息，需要与生成密钥和证书请求文件时设置的别名保持一致
- Key password：密钥的密码，需要与生成密钥和证书请求文件时设置的密码保持一致
- Sign alg：固定设置为“SHA256withECDSA”
- **Profile file：选择****申请调试Profile****时下载的.p7b文件**

- **Certpath file：选择****申请调试证书****时下载的.cer文件**

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713952489697-609637ba-efd7-4e65-a047-e215ade3b1d9.png)

### 1.1.6. 配置公钥指纹

- 登录[AppGallery Connect](https://developer.huawei.com/consumer/cn/service/josp/agc/index.html)，点击“我的项目”。
- 在项目列表中找到您的项目，在项目中点击您的应用/元服务。
- 在“项目设置 > 常规”页面的“应用”区域，点击“SHA256证书/公钥指纹”后的“添加公钥指纹（HarmonyOS API 9及以上）”

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1718323057285-a6f35dfc-dbee-49d7-98c5-a71ade647a12.png)

选择咱们添加的调试证书

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1714059045185-99450cdf-a07b-413c-bfdb-eaa3acbcb8f6.png)

- 在“选择SHA256公钥指纹”窗口，选择应用使用的证书对应的指纹，点击“确认”

## 1.2. 配置权限

https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/account-client-id-0000001658658849-V5

### 1.2.1. 配置Client ID

把ClientId后面的数字复制一下，放到项目的`module.json5`文件中

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713952868511-0a2cd6b7-9ade-48ba-82f9-a4b941d61bed.png)

```typescript
"module": {
  "name": "xxx",
  "type": "entry",
  "description": "xxx",
  "mainElement": "xxx",
  "deviceTypes": [],
  "pages": "xxx",
  "abilities": [],
  "metadata": [ // 配置信息如下
    {
      "name": "client_id",
      "value": "xxx"
    }
  ]
}
```

clientID：111009537

clientSecret: c084a00eb0f8cc2c6fe97f0c2d344e6a67a934ffdf3d334258268fd5836cc166

### 1.2.2. scope权限申请

登录华为开发者联盟，选择`管理中心->API服务->授权管理` ，选择目标应用的应用名称，服务选择“华为帐号服务”，选择“敏感权限”，再选择“获取您的手机号”或“获取并验证您的手机号”，点击“申请”

https://developer.huawei.com/consumer/cn/

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1713954638244-009edfe6-8dcf-4d94-8f1f-d180e27f2f67.png)

注：只要.p12 + .cer + .p7b三个文件保持不变，包名保持一致，任何新建项目都可以复用三个文件进行正常签名直接调试各种服务，无需重新走一遍流程

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1724649680224-b3103e24-9424-4ce9-9587-5109cd0feda1.png)

**注：**

1. 这一步之前随意填写即可申请通过，目前不容易通过，需要严格按照要求填写申请信息
2. 我们替换之前申请的证书进行测试，记得修改包名

1. 1. AppScope 下的 AppScope/app.json5，改包名

[📎meikou_mall.zip](https://www.yuque.com/attachments/yuque/0/2025/zip/38706227/1748074609614-310aa284-bedf-4c27-b82e-a32830f1e550.zip)

## 1.3. 实现华为授权登录

[快速验证](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/account-get-phonenumber-V5)

### 1.3.1. 实现流程图

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1716198008120-4d63091d-39aa-4c3b-a640-99963c3a7746.png)

1. 配置证书及权限
2. 调用华为登录的 api 拉起登录界面
3. 获取登录成功之后的 code（码）
4. 提交给应用的后端接口
5. 后端会将 code 提交给【华为服务器】验真
6. 成功返回用户信息
7. 本地拿到用户信息保存即可

注：

1. win 模拟器无法测试
2. 目前需要 真机 或者 mac（m 芯片）的模拟器

### 1.3.2. 获取华为登录 code

[参考文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/account-get-phonenumber-V5)

![img](https://cdn.nlark.com/yuque/0/2025/png/8435673/1743406297523-e0eea740-01ca-42fc-a712-05c0f713e12d.png)

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1718592642397-b190d724-24e2-4995-991b-04361ff48f7a.png)

1. **准备登录模块**

为了简化调用这里将华为登录的核心逻辑进行封装

```ts
commons/basic/src/main/ets/utils/HuaweiAuthPlugin.ets

import { authentication } from "@kit.AccountKit"
import { util } from "@kit.ArkTS";

export class HuaweiAuthManager {
  // 拉起华为登录
  async launchAuth() {
    try {
      // 1.创建授权请求
      const request = new authentication.HuaweiIDProvider().createAuthorizationWithHuaweiIDRequest()
      // 2.传递参数
      request.scopes = ['phone'];
      // 获取code需传如下permission
      request.permissions = ['serviceauthcode'];
      //
      request.forceAuthorization = true;

      request.state = util.generateRandomUUID(); // 随机UUID - 返回的state要和这个uuid对得上 没对上就说明有人篡改请求

      // controller的目的是发起请求
      const controller = new authentication.AuthenticationController(getContext())

      const result = await controller.executeRequest(request) as authentication.AuthorizationWithHuaweiIDResponse
      if (request.state === result.state) {
        // 说明请求是正常的
        AlertDialog.show({ message: result.data?.authorizationCode })
        return result.data?.authorizationCode
      } else {
        AlertDialog.show({ message: '华为登录请求被篡改！！！' })
        return Promise.reject(new Error("华为登录请求被篡改"))
      }

    } catch (error) {
      AlertDialog.show({ message: error.message })
      return Promise.reject(error)
    }

  }

  // 退出华为登录
  exitAuth() {

  }
}

export const huaweiAuthManager = new HuaweiAuthManager()
```

### 1.3.3. 实现华为登录

[接口文档](https://apifox.com/apidoc/shared-b2a05857-d21a-4a59-b3f8-aaf35972c78d/api-180356252)

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1718594814243-9d73cf54-9d85-4cd6-bcff-8d341383c05f.png)

- 封装华为登录的类型

```typescript
features/mine/src/main/ets/viewmodels/user.ets

export interface HuaweiLoginParams {
  clientId: string;

  /**
   * 客户端秘钥
   */
  clientSecret: string;

  /**
   * 华为授权码
   */
  code: string;
}
```

- 封装API

```typescript
features/mine/src/main/ets/api/user.ets

export const huaweiLoginAPI = (data: HuaweiLoginParams) => RequestRcp.post<HDMUser>("/login/huawei", data)
```

- 点击华为图标进行登录

```typescript
features/mine/src/main/ets/views/LoginView.ets

Image($r("app.media.ic_user_huawei"))
    .width(60)
    .height(60)
    .onClick(async () => {
      const code = (await huaweiAuthManager.launchAuth())! // 拉起华为登录
      const result = await huaweiLoginAPI({
        code,
        clientId: '111009537',
        clientSecret: '30ac635b8516278c75582b4bdf1a6cf06827d782d5ddc1c3f97a8e31cb1e761e'
      })
      auth.setUser(result)
      HMRouterMgr.pop() // 返回上一层

    })
```



### 1.3.4. 调整登出逻辑

**需求：**

1. 登出时额外调用华为登出

```typescript
import { authentication } from "@kit.AccountKit"
import { util } from "@kit.ArkTS";

export class HuaweiAuthManager {
  // 拉起华为登录
  async launchAuth() {
    try {
      // 1.创建授权请求
      const request = new authentication.HuaweiIDProvider().createAuthorizationWithHuaweiIDRequest()
      // 2.传递参数
      request.scopes = ['phone'];
      // 获取code需传如下permission
      request.permissions = ['serviceauthcode'];
      //
      request.forceAuthorization = true;

      request.state = util.generateRandomUUID(); // 随机UUID - 返回的state要和这个uuid对得上 没对上就说明有人篡改请求

      // controller的目的是发起请求
      const controller = new authentication.AuthenticationController(getContext())

      const result = await controller.executeRequest(request) as authentication.AuthorizationWithHuaweiIDResponse
      if (request.state === result.state) {
        // 说明请求是正常的
        return result.data?.authorizationCode
      } else {
        AlertDialog.show({ message: '华为登录请求被篡改！！！' })
        return Promise.reject(new Error("华为登录请求被篡改"))
      }

    } catch (error) {
      AlertDialog.show({ message: error.message })
      return Promise.reject(error)
    }

  }

  // 退出华为登录
  // 刷新token不需要做-因为有效期是180天
  async exitAuth() {
    const cancelRequest = new authentication.HuaweiIDProvider().createCancelAuthorizationRequest()
    const controller = new authentication.AuthenticationController()
    await controller.executeRequest(cancelRequest)

  }
}

export const huaweiAuthManager = new HuaweiAuthManager()

```

```ts
features/mine/src/main/ets/views/SettingView.ets

hdmDialogHelper.showConfirmDialog({
    title: '消息',
    content: '确认要退出当前账户吗?',
    rightAction: () => {
      auth.setUser({} as HDMUser)
      huaweiAuthManager.exitAuth() // 退出华为登录
      HMRouterMgr.pop()
    }
  })
```





# 十二、语音搜索

windows模拟器不支持语音转化-mac也不支持目前只能用手机

# 1. 语音搜索

录音-拿到录音的buffer(二进制)

buffer - 语音识别引擎- (文字)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/639379/1718148870337-ca021e53-7f4d-4195-a137-7fa15c206f45.png?x-oss-process=image%2Fformat%2Cwebp)

在搜索页中，常规的交互是用户在输入框中输入内容之后，点击搜索按钮进行搜索业务，为了提高用户体验，用户可以通过【语音】的方式输入想要搜索的关键词，省去打字的麻烦

![image.png](https://cdn.nlark.com/yuque/0/2024/png/639379/1718149046525-13ea1de0-640d-4f52-af01-bb0a8d03bb02.png?x-oss-process=image%2Fformat%2Cwebp)

录音把音频buffer传给语音转化引擎 - 输出文字



## 1.1. 组件整合

[键盘避让](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-uicontext-0000001774280798)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/639379/1718149324257-06d403e8-d1ff-4fa5-83c0-d098848dbedd.png?x-oss-process=image%2Fformat%2Cwebp)

**核心步骤：**

1. 创建组件
2. 整合图片
3. 在 features/home/src/main/ets/views/SearhView.ets 页面中引入

```ts
features/home/src/main/ets/components/HDMAudioSearch.ets

export enum VoiceState {
  DEFAULT,
  VOICING,
  VOICEOVER
}

@Preview
@ComponentV2
export struct HDMAudioSearch {
  @Local voiceState: VoiceState = VoiceState.DEFAULT
  @Local keyword: string = ''
  @Event
  onComplete: (keyword: string) => void = () => {
  }

  // 开始录音
  async startRecord() {

  }

  // 结束录音
  async closeRecord() {

  }

  aboutToAppear(): void {

  }

  build() {
    Column() {
      if (this.voiceState !== VoiceState.DEFAULT) {
        Column({ space: 16 }) {
          if (this.voiceState === VoiceState.VOICING) {
            Text('请说，我在聆听...')
              .fontSize(14)
            Text(this.keyword)
              .fontSize(14)
              .margin({
                top: 20
              })
          } else if (this.voiceState === VoiceState.VOICEOVER && this.keyword === '') {
            Text('未检测到语音，请长按按钮重试')
              .fontSize(14)
          }
          Text() {
            Span('你可以这样说：')
            Span('太阳眼镜/冬款连衣裙')
              .fontColor($r('[basic].color.gray'))
          }
          .fontSize(12)
        }
        .justifyContent(FlexAlign.Center)
        .height(150)
      }
      Blank()
      Button() {
        Row({ space: 4 }) {
          Image($r('sys.media.ohos_ic_public_voice'))
            .width(16)
            .aspectRatio(1)
            .fillColor($r('[basic].color.white'))
          if (this.voiceState === VoiceState.VOICING) {
            Text('松开立即搜索')
              .fontSize(14)
              .fontColor($r('[basic].color.white'))
          } else {
            Text('长按语音搜索')
              .fontSize(14)
              .fontColor($r('[basic].color.white'))
          }
        }
      }
      .padding({ left: 12, right: 12 })
      .height(36)
      .linearGradient({
        angle: 135,
        colors: [[$r('[basic].color.linear_begin'), 0], [$r('[basic].color.linear_end'), 1]]
      })
      .margin({ bottom: 16 })
      .gesture(
        LongPressGesture()
          .onAction(() => {
            // 开始录音
            this.startRecord()
          })
          .onActionEnd(() => {
            // 结束录音
            this.closeRecord()
          })
          .onActionCancel(() => {
            // 结束录音
            this.closeRecord()
          })
      )

    }
    .layoutWeight(1)
    .width('100%')
    .backgroundImage($r('app.media.search_bg'))
    .backgroundImageSize(ImageSize.Contain)
    .backgroundImagePosition(Alignment.Bottom)
    .onVisibleAreaChange([0, 1], () => {
      this.keyword = ''
      this.voiceState = VoiceState.DEFAULT
    })
  }
}
```

![image.png](https://cdn.nlark.com/yuque/0/2024/png/8435673/1730948503194-79cbc7d6-056a-43a4-b6fc-85abe4420675.png?x-oss-process=image%2Fformat%2Cwebp)

背景图放在home模块下

![image.png](https://cdn.nlark.com/yuque/0/2025/png/8435673/1743211122164-092c4024-11dc-4dd9-ab73-e8604d247409.png?x-oss-process=image%2Fformat%2Cwebp)

在搜索页面实现键盘避让

```ts
features/home/src/main/ets/views/SearchView.ets

import { AppStorageV2, promptAction, KeyboardAvoidMode } from '@kit.ArkUI'

  aboutToAppear() {
    this.getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.RESIZE)
  }
```



## 1.2. 申请权限

[声明权限](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/declare-permissions-V5)

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1718149416558-a6c3feb1-6e05-4a07-84d5-fe57684ac95c.png)

- 先看有没有 
- 没有再申请
- 申请通过一切ok
- 没通过就拉起设置页-setting方法直接可以设置即可



核心步骤：

1. module.json5里面申请权限

```ts
products/phone/src/main/module.json5

{
  "module": {
    "name": "phone",
    "type": "entry",
    "description": "$string:module_desc",
    "mainElement": "PhoneAbility",
    "deviceTypes": [
      "phone",
      "tablet",
      "2in1"
    ],
    "requestPermissions": [{
      "name": "ohos.permission.INTERNET"
    }, {
      "name": "ohos.permission.GET_NETWORK_INFO"
    }, {
      "name": "ohos.permission.MICROPHONE",
      "reason": "$string:mic_reason",
      "usedScene": {
        "when": "always",
        "abilities": ["PhoneAbility"]
      }

    }],
    "deliveryWithInstall": true,
    "installationFree": false,
    "pages": "$profile:main_pages",
    "abilities": [
      {
        "name": "PhoneAbility",
        "srcEntry": "./ets/phoneability/PhoneAbility.ets",
        "description": "$string:PhoneAbility_desc",
        "icon": "$media:foreground",
        "label": "$string:PhoneAbility_label",
        "startWindowIcon": "$media:startIcon",
        "startWindowBackground": "$color:start_window_background",
        "exported": true,
        "skills": [
          {
            "entities": [
              "entity.system.home"
            ],
            "actions": [
              "action.system.home"
            ]
          }
        ]
      }
    ],
    "extensionAbilities": [
      {
        "name": "PhoneBackupAbility",
        "srcEntry": "./ets/phonebackupability/PhoneBackupAbility.ets",
        "type": "backup",
        "exported": false,
        "metadata": [
          {
            "name": "ohos.extension.backup",
            "resource": "$profile:backup_config"
          }
        ]
      }
    ]
  }
}
```

封装鉴权工具

- 先检查-需要tokenId
- 需要bundleManager.getBundleInfoForSelft获取tokenId
- 得到检查结果-有权限正常执行, 没有权限尝试申请
- 尝试申请-只能弹出一次，如果没有弹出说明之前已经申请过-同意/不同意
- 同意-正常走
- 不同意- onSetting-可以无限弹

```ts
commons/basic/src/main/ets/utils/AccessManager.ets

import { abilityAccessCtrl, bundleManager, Permissions } from "@kit.AbilityKit";

export class AccessManager {
  async checkPermission(permissions: Permissions[], success: () => void, fail?: () => void) {
    // 1，先看有没有
    const app = bundleManager.getBundleInfoForSelfSync(bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION)
    const manager = abilityAccessCtrl.createAtManager()
    const listResult = permissions.map(p => manager.checkAccessTokenSync(app.appInfo.accessTokenId, p))
    // 检查所有的权限的结果
    const isOK = listResult.every(res => res === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED)
    if (isOK) {
      success()
    } else {
      // 第一次申请权限
      const result = await manager.requestPermissionsFromUser(getContext(), permissions)
      const againCheck = result.authResults.every(res => res === 0)
      if (againCheck) {
        success()
      } else {
        const secondCheck = await manager.requestPermissionOnSetting(getContext(), permissions)
        const checkResult = secondCheck.every(res => res === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED)
        if (checkResult) {
          success()
        } else {
          fail?.()
          // fail && fail()
          // if (fail) {
          //   fail()
          // }
        }
      }
    }
    //

  }
}

export const accessManager = new AccessManager()
```

1. 长按语音搜索时，进行鉴权-只在长按语音时触发

```ts
features/home/src/main/ets/components/HDMAudioSearch.ets

// 开始录音
  async startRecord() {
    accessManager.checkPermission(["ohos.permission.MICROPHONE"], () => {
      promptAction.showToast({ message: '可以开始录音了' })
    }, () => {
      promptAction.showToast({ message: '您当前没有开启权限，无法使用语音功能' })
    })

  }
```



## 1.3. 语音录制

录制语音-AvRecorder-AvPlayer- 直接写入音频文件

AudioCapurter-pcm音频-语音识别-只能识别pcm音频

语音转成文字

[AudioCapturer](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/using-audiocapturer-for-recording-V5)

- 封装录音的工具类

录的音频数据要实时转化文字-

不需要写入沙箱文件- 音频数据以内存形式存在

```ts
commons/basic/src/main/ets/utils/AudioCapturerManager.ets

import { audio } from "@kit.AudioKit"

export class AudioCapturerManager {
  capturer: audio.AudioCapturer | null = null

  // 创建录音对象
  async initCapturer() {

    let audioStreamInfo: audio.AudioStreamInfo = {
      samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_16000, // 采样率 语音识别只能识别16000
      channels: audio.AudioChannel.CHANNEL_1, // 通道1
      sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE, // 采样格式
      encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW // 编码格式
    };

    let audioCapturerInfo: audio.AudioCapturerInfo = {
      source: audio.SourceType.SOURCE_TYPE_MIC,
      capturerFlags: 0
    };

    let audioCapturerOptions: audio.AudioCapturerOptions = {
      streamInfo: audioStreamInfo,
      capturerInfo: audioCapturerInfo
    };
    this.capturer = await audio.createAudioCapturer(audioCapturerOptions);
  }

  async start(callback: (bf: ArrayBuffer) => void) {
    // 1.创建采集器
    if (!this.capturer) {
      await this.initCapturer()
    }
    // 2.监听readData
    this.capturer?.on("readData", (bf) => {
      // bf -> 文字 实时的
      callback(bf)
    })
    // 3.开始录制
    this.capturer?.start() // 开始录音

  }

  async stop() {
    await this.capturer?.stop()
    this.capturer?.release()
    this.capturer = null
  }
}

export const audioCapturerManager = new AudioCapturerManager()
```

- 在语音搜索组件中进行开始和结束

```typescript
features/home/src/main/ets/components/HDMAudioSearch.ets

// 开始录音
  async startRecord() {
    accessManager.checkPermission(["ohos.permission.MICROPHONE"], () => {
      // promptAction.showToast({ message: '可以开始录音了' })
      audioCapturerManager.start((bf) => {
        HDMLog.info("录音中-" + bf.byteLength)
      })
    }, () => {
      promptAction.showToast({ message: '您当前没有开启权限，无法使用语音功能' })
    })

  }

  // 结束录音
  async closeRecord() {
    audioCapturerManager.stop()
  }
```

![img](https://cdn.nlark.com/yuque/0/2025/png/8435673/1743215994974-236a1442-aa61-4969-9004-e019effe102f.png)

- 真机调试

模拟器不需要签名和证书

真机必须得有签名和证书-自动签名和手动签名

自动签名和证书-p12-p7b-cer-csr

![img](https://cdn.nlark.com/yuque/0/2024/png/8435673/1732437259201-c451cec4-571c-4a46-89df-78aedc21ed4a.png)

自动签名![img](https://cdn.nlark.com/yuque/0/2024/png/8435673/1732437298039-6e3a73b7-1d64-4560-8fab-ecba79bd1afa.png)

![img](https://cdn.nlark.com/yuque/0/2024/png/8435673/1732437315058-821da76a-a25f-45c5-88f8-c600e7dfe5ab.png)

![img](https://cdn.nlark.com/yuque/0/2024/png/8435673/1732437367378-58467a54-7f71-4b36-9dd2-67acf26247f0.png)



[语音识别引擎-core-speech能力](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/speechrecognizer-guide-V5)

```ts
commons/basic/src/main/ets/utils/CoreSpeechManger.ets

import { speechRecognizer } from '@kit.CoreSpeechKit';
import { HDMLog } from '.';

export class CoreSpeechManager {
  asrEngine: speechRecognizer.SpeechRecognitionEngine | null = null // 语音识别引擎
  // 引擎得提前初始化 -录音已经有buffer 你说了一句你好 需要保证此时语音识别引擎已经准备好了
  sessionId: string = Date.now().toString() // 必须是数字字符串
  async initEngine() {

    // 创建引擎，通过callback形式返回
    // 设置创建引擎参数
    let extraParam: Record<string, Object> = { "locate": "CN", "recognizerMode": "short" };
    let initParamsInfo: speechRecognizer.CreateEngineParams = {
      language: 'zh-CN', // 支持中文
      online: 1, // 离线模式 比较弱 没那么大的准确性
      extraParams: extraParam
    };
    // 调用createEngine方法
    this.asrEngine = await speechRecognizer.createEngine(initParamsInfo);
    this.setListener() // 设置监听
    this.startListening() // 开始监听
  }

  // 设置监听回调
  private setListener() {
    // 创建回调对象
    let setListener: speechRecognizer.RecognitionListener = {
      // 开始识别成功回调
      onStart(sessionId: string, eventMessage: string) {
        console.info(`onStart, sessionId: ${sessionId} eventMessage: ${eventMessage}`);
      },
      // 事件回调
      onEvent(sessionId: string, eventCode: number, eventMessage: string) {
        console.info(`onEvent, sessionId: ${sessionId} eventCode: ${eventCode} eventMessage: ${eventMessage}`);
      },
      // 识别结果回调，包括中间结果和最终结果
      onResult(sessionId: string, result: speechRecognizer.SpeechRecognitionResult) {
        HDMLog.info(result.result)
        console.info(`onResult, sessionId: ${sessionId} sessionId: ${JSON.stringify(result)}`);
      },
      // 识别完成回调
      onComplete(sessionId: string, eventMessage: string) {
        console.info(`onComplete, sessionId: ${sessionId} eventMessage: ${eventMessage}`);
      },
      // 错误回调，错误码通过本方法返回
      // 如：返回错误码1002200006，识别引擎正忙，引擎正在识别中
      // 更多错误码请参考错误码参考
      onError(sessionId: string, errorCode: number, errorMessage: string) {
        console.error(`onError, sessionId: ${sessionId} errorCode: ${errorCode} errorMessage: ${errorMessage}`);
      }
    }
    // 设置回调
    this.asrEngine?.setListener(setListener);
  }

  // 开启监听
  private startListening() {
    let recognizerParams: speechRecognizer.StartParams = {
      sessionId: this.sessionId,
      audioInfo: {
        audioType: 'pcm',
        sampleRate: 16000,
        soundChannel: 1,
        sampleBit: 16
      } //audioInfo参数配置请参考AudioInfo
    }
    // 调用开始识别方法
    this.asrEngine?.startListening(recognizerParams);
  }

  // 开始分析
  startTransVoice(bf: ArrayBuffer) {
    this.asrEngine?.writeAudio(this.sessionId, new Uint8Array(bf)) // 写入音频流
  }

  // 停止分析
  stopTransVoice() {
    this.asrEngine?.finish(this.sessionId) // 结束识别
    this.asrEngine?.shutdown() // 释放资源
    this.asrEngine = null // 内存清空
    this.sessionId = Date.now().toString() // 重新初始化sessionId
  }
}

export const coreSpeechManager = new CoreSpeechManager()
```

- 语音识别调用

```ts
 async startRecord() {
    accessManager.checkPermission(["ohos.permission.MICROPHONE"], async () => {
      // promptAction.showToast({ message: '可以开始录音了' })
      await coreSpeechManager.initEngine() // 先初始化引擎
      audioCapturerManager.start((bf) => {
        // HDMLog.info("录音中-" + bf.byteLength) // bf -> 文字
        coreSpeechManager.startTransVoice(bf) // 将buffer源源不断的传递给识别引擎
      })
    }, () => {
      promptAction.showToast({ message: '您当前没有开启权限，无法使用语音功能' })
    })

  }

  // 结束录音
  async closeRecord() {
    await audioCapturerManager.stop() // 停止录音
    coreSpeechManager.stopTransVoice() // 停止语音分析
  }

```

- 语音识别文字到页面显示

- 给语音识别引擎添加回调函数

```ts
commons/basic/src/main/ets/utils/CoreSpeechManger.ets

import { speechRecognizer } from '@kit.CoreSpeechKit';
import { HDMLog } from '.';
import { emitter } from '@kit.BasicServicesKit';

export class CoreSpeechManager {
  asrEngine: speechRecognizer.SpeechRecognitionEngine | null = null // 语音识别引擎
  // 引擎得提前初始化 -录音已经有buffer 你说了一句你好 需要保证此时语音识别引擎已经准备好了
  sessionId: string = Date.now().toString() // 必须是数字字符串
  resultCallBack?: (content: string) => void // 本身定义一个函数

  async initEngine(callBack: (content: string) => void) {
    this.resultCallBack = callBack // 将外界传入的函数赋值给本身的一个函数
    // 创建引擎，通过callback形式返回
    // 设置创建引擎参数
    let extraParam: Record<string, Object> = { "locate": "CN", "recognizerMode": "short" };
    let initParamsInfo: speechRecognizer.CreateEngineParams = {
      language: 'zh-CN', // 支持中文
      online: 1, // 离线模式 比较弱 没那么大的准确性
      extraParams: extraParam
    };
    // 调用createEngine方法
    this.asrEngine = await speechRecognizer.createEngine(initParamsInfo);
    this.setListener() // 设置监听
    this.startListening() // 开始监听
  }

  // 设置监听回调
  private setListener() {
    // 创建回调对象
    let setListener: speechRecognizer.RecognitionListener = {
      // 开始识别成功回调
      onStart(sessionId: string, eventMessage: string) {
        console.info(`onStart, sessionId: ${sessionId} eventMessage: ${eventMessage}`);
      },
      // 事件回调
      onEvent(sessionId: string, eventCode: number, eventMessage: string) {
        console.info(`onEvent, sessionId: ${sessionId} eventCode: ${eventCode} eventMessage: ${eventMessage}`);
      },
      // 识别结果回调，包括中间结果和最终结果
      onResult: (sessionId: string, result: speechRecognizer.SpeechRecognitionResult) => {
        // HDMLog.info(result.result)
        // emitter
        // eventHub
        // 回调函数
        this.resultCallBack?.(result.result) // 回调函数传出文本
        console.info(`onResult, sessionId: ${sessionId} sessionId: ${JSON.stringify(result)}`);
      },
      // 识别完成回调
      onComplete(sessionId: string, eventMessage: string) {
        console.info(`onComplete, sessionId: ${sessionId} eventMessage: ${eventMessage}`);
      },
      // 错误回调，错误码通过本方法返回
      // 如：返回错误码1002200006，识别引擎正忙，引擎正在识别中
      // 更多错误码请参考错误码参考
      onError(sessionId: string, errorCode: number, errorMessage: string) {
        console.error(`onError, sessionId: ${sessionId} errorCode: ${errorCode} errorMessage: ${errorMessage}`);
      }
    }
    // 设置回调
    this.asrEngine?.setListener(setListener);
  }

  // 开启监听
  private startListening() {
    let recognizerParams: speechRecognizer.StartParams = {
      sessionId: this.sessionId,
      audioInfo: {
        audioType: 'pcm',
        sampleRate: 16000,
        soundChannel: 1,
        sampleBit: 16
      } //audioInfo参数配置请参考AudioInfo
    }
    // 调用开始识别方法
    this.asrEngine?.startListening(recognizerParams);
  }

  // 开始分析
  startTransVoice(bf: ArrayBuffer) {
    this.asrEngine?.writeAudio(this.sessionId, new Uint8Array(bf)) // 写入音频流
  }

  // 停止分析
  stopTransVoice() {
    this.asrEngine?.finish(this.sessionId) // 结束识别
    this.asrEngine?.shutdown() // 释放资源
    this.asrEngine = null // 内存清空
    this.sessionId = Date.now().toString() // 重新初始化sessionId
  }
}

export const coreSpeechManager = new CoreSpeechManager()
```

- 语音搜索组件传入

```typescript
features/home/src/main/ets/components/HDMAudioSearch.ets

// 开始录音
  async startRecord() {
    accessManager.checkPermission(["ohos.permission.MICROPHONE"], async () => {
      this.voiceState = VoiceState.VOICING
      // promptAction.showToast({ message: '可以开始录音了' })
      await coreSpeechManager.initEngine((content) => {
        this.keyword = content
      }) // 先初始化引擎
      audioCapturerManager.start((bf) => {
        // HDMLog.info("录音中-" + bf.byteLength) // bf -> 文字
        coreSpeechManager.startTransVoice(bf) // 将buffer源源不断的传递给识别引擎
      })
    }, () => {
      promptAction.showToast({ message: '您当前没有开启权限，无法使用语音功能' })
    })

  }
// 结束录音
  async closeRecord() {
    this.keyword = ""
    this.voiceState = VoiceState.DEFAULT
    await audioCapturerManager.stop() // 停止录音
    coreSpeechManager.stopTransVoice() // 停止语音分析
  }
 @Computed
  get btnWidth() {
    if (this.voiceState === VoiceState.DEFAULT) {
      return 150
    } else {
      return 200
    }
  }
```

![img](https://cdn.nlark.com/yuque/0/2025/png/8435673/1743231752532-e841e254-6e78-4b28-9b15-447e33813ae3.png)

## 1.4. 语音搜索跳转到搜索结果

- 拿到语音识别的文本-去掉多余的符号

```typescript
features/home/src/main/ets/components/HDMAudioSearch.ets

// 结束录音
  async closeRecord() {
    // 将文本替换特殊字符
    this.onComplete(this.keyword.replace(/[^\p{L}\p{N}\s]/gu, '')) // 语音识别结果传到三层组件
    this.keyword = ""
    this.voiceState = VoiceState.DEFAULT
    await audioCapturerManager.stop() // 停止录音
    coreSpeechManager.stopTransVoice() // 停止语音分析
  }
```

- 松手时，通过onComplete函数通知父组件进行跳转

```ts
    features/home/src/main/ets/views/SearchView.ets

    // 语音搜索组件
      HDMAudioSearch({
        onComplete: (keyword) => {
          this.keyword = keyword
          HMRouterMgr.push({
            pageUrl: PAGE_PATH.SEARCH_RESULT_PAGE,
            param: {
              keyword: this.keyword
            }
          })
        }
      })
```

