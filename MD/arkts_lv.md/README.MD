### 1. V2 的 `@Monitor` 有什么作用？

**答：**

- 用于监听某个状态的变化，相当于数据驱动的副作用函数。

```
@Local count: number = 0;

@Monitor('count')
onCountChanged() {
  console.log(`count变化为 ${this.count}`);
}
```

### 2. V1 和 V2 的主要区别是什么？

**答：**

- 语法更简洁，属性从函数式传参改为对象式。
- 状态管理体系优化（@State/@Link → @Local/@Param/@Monitor）。
- 生命周期更细粒度，更偏向响应式监听。
- 性能更好，支持局部UI刷新和组件复用。



### 3.V2 常见修饰器

| 修饰器         | 含义                              | 使用场景                      |
| -------------- | --------------------------------- | ----------------------------- |
| `@ComponentV2` | 声明一个组件                      | 新语法必须加                  |
| `@Local`       | 本地状态（替代V1的`@State`）      | 组件内部状态管理              |
| `@Param`       | 父组件传入参数（替代V1的`@Prop`） | 父传子                        |
| `@Monitor`     | 监听数据变化                      | 替代部分 `aboutToAppear` 场景 |
| `@Builder`     | 定义 UI 片段                      | 类似 slot，便于复用           |
| `@Reusable`    | 声明组件可复用                    | 提升性能                      |



### 4.ArkUI 中高级组件与布局

1. **布局与自适应**
   - Flex 布局进阶（flexGrow、flexShrink、justifyContent、alignItems）。
   - Grid、ConstraintLayout 与复杂响应式布局。
   - 多设备适配（手机、平板、手表、车机）。
2. **组件化进阶**
   - 组件函数与 Builder 模式（@Builder/@Reusable）。
   - 状态提升（State Lifting）与父子通信模式。
   - 插槽（Slot）和组合复用技巧。
3. **性能优化**
   - 避免不必要的组件刷新（局部更新）。
   - 使用 lazy load 列表、VirtualList 渲染优化大数据。
   - 图片缓存和内存管理。
4. **动画与手势**
   - Motion / Animation API（连续动画、弹性动画、关键帧动画）。
   - Gesture 事件（Drag、Swipe、Pinch、多点触控）。

### 5.系统能力与跨设备能力

1. **应用能力**
   - Ability 生命周期与 UI 生命周期区别。
   - 数据存储方式（Preferences、RDB、File）和异步操作。
   - Router 路由管理、页面参数传递。
2. **系统服务**
   - 网络请求、后台任务（Worker/Task）。
   - 多媒体能力（Camera、Audio、Video、MediaPlayer）。
   - 设备能力（传感器、GPS、蓝牙、NFC）。
3. **分布式能力**
   - 分布式任务、分布式数据共享。
   - 分布式设备发现和连接。
   - 多设备 UI 和能力迁移（如音乐播放迁移）。

### 6. ArkTS 响应式机制原理是什么？

**答：**

- ArkTS 基于 **声明式 UI + 响应式数据绑定**。
- 当 `@State`/`@Local` 等修饰的数据变化时，ArkUI 会触发 **依赖收集**，只刷新依赖该数据的 UI 节点。
- 实现方式类似 **虚拟DOM diff**，但更轻量，直接对 Fiber Tree（UI渲染树）做局部刷新。
- 优点：避免全量刷新，提升性能。

------

### 7. V1 / V2 组件生命周期的区别和使用场景？

**答：**

- **V1 生命周期**：
  - `aboutToAppear`、`aboutToDisappear`（组件显示/销毁）。
  - `onPageShow`、`onPageHide`（页面切换）。
- **V2 生命周期**：
  - 弱化传统生命周期，增强 **数据驱动**。
  - `@Monitor` 可直接监听变量变化，减少生命周期钩子使用。
- **使用场景**：
  - V1：传统页面逻辑，适合简单组件。
  - V2：更响应式，适合复杂状态管理、性能优化场景。

------

### 8. Flex 布局与 Grid 布局的适用场景对比？

**答：**

- **Flex**：
  - 一维布局（横向或纵向）。
  - 适合内容自适应、按钮组、导航栏、居中对齐。
- **Grid**：
  - 二维布局，支持行列。
  - 适合 **表格、相册、商品列表**。

**口诀**：Flex 管“一条线”，Grid 管“网格”。

------

### 9. 如何实现跨组件、跨页面的数据共享？

**答：**

- **父子组件**：
  - 父 → 子：`@Param`（V2）/`@Prop`（V1）。
  - 子 → 父：回调函数。
- **兄弟组件**：
  - 使用 `@Provide` / `@Consume` 提供上下文共享。
- **跨页面**：
  - 通过 `router.push({ params: {...} })` 传参。
  - 或使用全局状态管理（类似 Redux / Store 模式）。

------

### 10. 分布式能力在多设备场景的具体应用？

**答：**

- **分布式文件**：手机与平板共享文件系统。
- **分布式数据管理**：云端/多设备同步购物车、文档编辑。
- **分布式任务调度**：手机上的任务迁移到平板/车机继续执行。
- **分布式 UI**：同一个应用在不同设备上展示不同交互。

**案例**：手机播放音乐 → 车机继续播放；手表接电话 → 切换到手机继续通话。

------

### 11. 如何优化列表渲染大数据？

**答：**

- 使用 **LazyForEach / LazyList / VirtualList**，按需加载。
- **分页加载**，避免一次性渲染全部。
- 使用 **缓存（Recycle 机制）**，避免反复创建组件。
- 异步加载数据，防止阻塞 UI 线程。

------

### 12. 如何在组件中监听状态变化而不刷新整个页面？

**答：**

- V1：使用 `@Link` 精准绑定子组件。
- V2：使用 `@Monitor` 针对性监听变量变化。
- 拆分组件，保持状态作用域最小化，减少无关组件刷新。

------

### 13. 多模块 Ability 之间如何通信？

**答：**

- **FA（FeatureAbility） → PA（ParticleAbility）**：通过 `call()` 方式调用服务。
- **PageAbility 之间**：通过 `router` 传递参数或使用 DataAbility。
- **跨模块**：可用 **分布式数据管理（DDM）** 或 **事件总线（EventHub）**。

------

### 14. 如何做应用性能优化（CPU、内存、FPS）？

**答：**

1. **CPU**：
   - 避免主线程做耗时任务 → 使用 Worker。
   - 减少频繁重绘（避免 setState 过度触发）。
2. **内存**：
   - 图片缓存、按需释放。
   - 避免内存泄漏（定时器/监听器及时销毁）。
3. **FPS**：
   - 使用 GPU 加速（减少复杂布局嵌套）。
   - 动画合并，避免掉帧。
   - 列表虚拟化渲染。

------

### 15. 如何实现 UI 响应式布局在不同设备屏幕上自适应？

**答：**

- 使用 **相对布局（Flex、Grid）**，避免绝对值。
- 使用 **百分比宽高**、`weight`、`constraintSize`。
- **媒体查询**（根据设备宽高/分辨率调整布局）。
- 提供 **多套布局资源**（如 phone、pad、wearable）。





## **HarmonyOS核心技术理念**

**一个理念**：分布式、全场景。

**两大核心**：微内核 + 分布式软总线。

**三大关键**：一次开发多端部署、元服务、跨设备协同。

**四大能力**：安全、流畅、互联、智能。

### 16.一、整体理念

**HarmonyOS 的核心设计理念是什么？**

- 答：分布式、一次开发多端部署、微内核架构、安全高效、面向全场景智能生活。

**鸿蒙和传统的 Android、iOS 有什么根本区别？**

- 答：Android/iOS 本质上是单设备 OS，而鸿蒙强调 **多设备融合（分布式能力）**，同一套应用可以运行在手机、平板、手表、电视、车机、IoT 设备上。

**什么是元服务（Atomic Service），它解决了什么问题？**

- 答：轻量化应用形态，不用下载安装即可使用，降低用户使用门槛；同时便于跨设备流转。

### 17.架构理念

1. **为什么鸿蒙采用微内核架构？**
   - 答：提高安全性和可扩展性。微内核只保留最基本的 IPC、任务调度、内存管理等，其他功能以服务形式运行，避免单点故障。
2. **微内核相比宏内核的优劣？**
   - 优点：安全（更小的攻击面）、灵活、适合多设备。
   - 缺点：实现复杂，性能上需要额外优化（鸿蒙通过 IPC、消息机制优化）。

#### 分布式理念

1. **什么是分布式软总线（SoftBus）？**
   - 答：一种底层通信机制，把不同硬件设备虚拟成“超级终端”，实现跨设备的发现、认证、传输。
2. **分布式任务调度的核心作用是什么？**
   - 答：应用的任务可以跨设备迁移，比如视频通话从手机无缝切到电视，游戏从平板切到手机继续运行。
3. **分布式数据管理是如何实现的？**
   - 答：通过分布式数据库（Data Management Service），使多设备间的数据共享与一致性存储。



## 18.**HarmonyOS应用架构设计**

答:HarmonyOS 应用架构基于微内核 + 分布式设计，应用采用 Stage 模型，以 Ability 为核心运行单元，分为 UIAbility 和 ServiceAbility。界面使用 ArkTS 声明式 UI，支持状态驱动。应用通过 HAP 模块化拆分，支持原子服务轻量运行。同时依托分布式能力（任务调度、数据管理、SoftBus），实现一次开发、多端部署和跨设备流转。

### 1. **整体架构层次**

HarmonyOS 应用主要由以下几层组成：

1. **UI 层（ArkUI）**
   - 基于 **声明式 UI 框架**（类似 React/Vue 思想）。
   - 开发语言：ArkTS（方舟 TypeScript 方言）。
   - 通过组件（Button、List、Text 等）+ 状态驱动（@State、@Prop、@Link）。
2. **应用框架层（App Framework）**
   - **Ability**：应用的最小运行单元。
     - `UIAbility` → 提供 UI 界面。
     - `ServiceAbility` → 提供后台服务。
   - **Stage 模型**（推荐）：多 UIAbility，模块化更强。
3. **分布式能力层**
   - **分布式任务调度** → 应用可以跨设备流转。
   - **分布式数据管理** → 跨设备共享数据。
   - **分布式软总线（SoftBus）** → 设备间通信。
4. **系统服务层**
   - 媒体、位置、通知、账号、窗口管理、安全等。

------

### 2. **应用模型**

鸿蒙从 **FA 模型 → Stage 模型** 进化：

- **FA 模型（Feature Ability）**（早期，兼容安卓）：
  - UIAbility + PageAbility 混合，适合小型应用。
- **Stage 模型（主流）**：
  - 明确区分 UIAbility、ServiceAbility。
  - 更适合大型、分布式应用开发。

👉 面试要点：

> **新项目必须用 Stage 模型**，它支持模块化开发、跨设备迁移能力。

------

### 3. **分布式应用架构**

核心是 **一次开发，多端部署，跨设备流转**。

- **超级终端理念**：手机、手表、平板、车机等设备通过分布式能力组成一个整体。
- **应用逻辑抽象层**：把业务逻辑和 UI 解耦。
- **跨设备迁移**：
  - 例如：视频通话从手机 → 平板 → 智能屏无缝切换。
  - 底层由 **AbilityContinuation（能力迁移）** 支持。

------

### 4. **模块化与原子化**

1. **HAP（Harmony Ability Package）**
   - 鸿蒙应用的安装包，可以按功能拆分。
   - 多个 HAP 组成一个 App（Entry HAP、Feature HAP、Shared HAP）。
2. **原子服务（Atomic Service）**
   - 轻量化应用形态，不用下载安装即可使用。
   - 一般以 **卡片（Card）** 方式呈现，支持分布式调用。

------

### 5. **典型应用架构图**

```
┌──────────────────────┐
│      UI 层 (ArkUI)    │ ← ArkTS 声明式 UI，跨端自适应
├──────────────────────┤
│   应用框架 (Ability)  │ ← Stage 模型: UIAbility + ServiceAbility
├──────────────────────┤
│ 分布式能力 (SoftBus) │ ← 分布式调度、数据、通信
├──────────────────────┤
│    系统服务 (Media等) │
├──────────────────────┤
│    内核 (微内核架构)  │
└──────────────────────┘
```

------

### 6. **架构设计关键点**

- **分布式优先**：考虑多设备协同，而不仅是单端。
- **模块化**：业务拆分为多个 HAP，方便升级和复用。
- **状态驱动 UI**：ArkTS 的 `@State`、`@Prop`、`@Link` 替代传统 MVVM。
- **轻应用/元服务**：原子服务适合低频场景。
- **安全性**：最小权限 + TEE（可信执行环境）。

## 19.ArkTS原理和实践**

**ArkTS 原理**：基于 TypeScript，静态增强，由 Ark Compiler 编译运行；结合声明式 UI 框架 ArkUI。

**核心特性**：声明式 UI、状态驱动、模块化、分布式能力。

**实践应用**：以 Stage 模型 + ArkUI 组件化开发，适合跨设备、多端协同场景。

### 1. 定义

- **ArkTS** 是基于 **TypeScript 的方言**，由华为方舟编译器（Ark Compiler）支持。
- 它不是单纯的 TS，而是针对 **鸿蒙应用开发** 增加了 UI 声明式语法和状态管理能力。

### 2. 为什么要有 ArkTS？

- **原生 TS/JS** → 动态语言，运行效率低。
- **ArkTS** → 静态增强 + 方舟编译器 → 直接编译为字节码/机器码，性能更好。
- 同时内置 **UI 声明式框架（ArkUI）**，提升开发效率。

### 3. 核心原理

1. **编译原理**：
   - ArkTS 源码 → 方舟编译器 **AOT 编译** → 字节码 → HarmonyOS 虚拟机运行。
   - 部分场景支持 JIT/解释执行。
2. **UI 渲染原理**：
   - ArkTS 提供 **声明式 UI**，通过状态变量驱动 UI 变化（类似 React/Vue）。
   - 当 `@State` 变量改变时，框架自动触发 UI 更新。
3. **运行机制**：
   - ArkTS 程序运行在 **Stage 模型** 的 Ability 框架内。
   - 生命周期由系统管理（UIAbility / ServiceAbility）。

##  20.ArkTS 关键特性

### 1. 声明式 UI

```
@Entry
@Component
struct HelloWorld {
  @State message: string = "Hello ArkTS"

  build() {
    Column() {
      Text(this.message)
        .fontSize(20)
        .onClick(() => {
          this.message = "Clicked!"
        })
    }
  }
}
```

- **特点**：UI 由数据驱动，而不是命令式更新。
- 类似 React 的 Hooks，但更轻量，直接绑定变量。

------

### 2. 状态管理

- `@State` → 本地状态（组件内）。
- `@Prop` → 父组件传值，单向绑定。
- `@Link` → 父子双向绑定。
- `@Provide / @Consume` → 跨组件树共享数据。
- `@Observed / @ObjectLink` → 复杂对象的响应式。

👉 面试高频点：

- 什么时候用 `@State`，什么时候用 `@Link`？
  - `@State` → 内部变量。
  - `@Link` → 父子双向交互。

------

### 3. 并发与异步

- ArkTS 支持 **Promise / async-await**。
- 同时提供 **任务调度 API**，适配分布式场景。

------

### 4. 跨设备分布式能力

- ArkTS 支持调用 **分布式 API**：
  - `@ohos.distributedData` → 分布式数据库。
  - `@ohos.distributedHardware` → 多设备互联。

## **ArkUI开发**

**ArkUI 是基于 ArkTS 的声明式 UI 框架，强调状态驱动、组件化、跨端适配，开发体验类似 React，但更贴近系统底层，性能更高。轻量高效**

## 21.**HarmonyOS关键技术能力开发**

HarmonyOS 的关键技术能力集中在分布式、多端协同和轻量化服务上。
 首先是 **分布式软总线**，实现多设备间的发现、认证和高速通信；
 其次是 **分布式任务调度**，支持应用在不同设备间无缝流转；
 还有 **分布式数据管理**，保证跨设备的数据一致性；
 此外，鸿蒙引入了 **原子服务**，让用户免安装即用。
 在开发层面，HarmonyOS 提供了对应的 ArkTS API，比如 `deviceManager`、`distributedAbilityManager`、`distributedData`，开发者可以直接调用这些接口实现跨设备能力。

投屏、跨端视频通话、云端购物车、免安装服务。

## 22.工程管理、代码编辑、调试与定位**

在工程管理上，鸿蒙应用采用多模块 HAP 架构，我会根据功能划分 Entry/Feature/Shared HAP，并在 module.json5 中配置依赖和权限；
 在代码编辑上，主要使用 ArkTS + ArkUI 声明式开发，结合状态管理机制组织组件；
 在调试阶段，我会用 DevEco Studio 的断点调试、真机调试，以及 `hilog` 日志定位；
 在问题定位方面，会借助 Hilog Viewer、Profiler 做性能分析，结合 AGC 崩溃分析监控线上问题。

###  1. 工程管理 (Project Management)

HarmonyOS 应用在 **DevEco Studio** 中管理，核心点：

#### 工程结构

- **App 工程**：包含多个模块（HAP）。
- **模块 (HAP)**
  - **Entry HAP** → 主入口模块（必须有）。
  - **Feature HAP** → 功能扩展模块。
  - **Shared HAP** → 公共库模块，供多个 HAP 共享。

#### 配置文件

- `module.json5` → 模块配置（Ability 类型、权限、依赖）。
- `app.json5` → 应用全局配置（应用 ID、版本号、图标）。

#### 依赖管理

- 通过 `ohpm`（OpenHarmony 包管理工具）管理依赖，类似 npm。
- 例如：

```
ohpm install @ohos/hypium --save-dev
```

👉 面试要点：

- 鸿蒙应用是 **多模块架构**（HAP），支持按功能拆分，方便升级和分布式部署。

------

### 2. 代码编辑 (Code Editing)

#### ArkTS 开发特色

- **声明式 UI**：ArkUI 组件驱动开发。
- **状态管理**：`@State / @Prop / @Link / @Observed`。
- **智能提示与代码片段**：DevEco Studio 提供 ArkTS/JS 智能补全。

#### 代码规范

- 遵循 **华为鸿蒙开发编码规范**：
  - 命名规范（CamelCase）。
  - 模块解耦（一个 HAP = 一个功能域）。
  - 资源统一管理（`resources/` 文件夹）。

------

### 3. 调试 (Debugging)

#### 调试方式

1. **设备调试**

   - 通过 USB / Wi-Fi 连接手机、平板、Watch 设备。
   - 支持 **真机/模拟器调试**。

2. **断点调试**

   - 在 ArkTS 代码设置断点 → 单步执行 / 查看变量。

3. **日志调试**

   - 使用 `hilog` 打印：

   ```
   import hilog from '@ohos.hilog';
   
   hilog.info(0x0001, "APP", "当前用户：%{public}s", userName);
   ```

   - `%{public}` / `%{private}` 控制日志敏感信息。

------

### 4. 定位问题 (Troubleshooting)

#### 工具支持

- **Hilog Viewer** → 查看系统日志。
- **Profiler** → 性能分析（CPU、内存、耗电）。
- **Crash 分析** → DevEco Studio + AGC（AppGallery Connect 崩溃服务）。

#### 常见问题定位

1. **UI 不更新** → 检查 `@State` 是否正确使用。
2. **跨设备失败** → 检查 SoftBus 权限 & deviceId。
3. **卡顿/内存泄漏** → Profiler 跟踪内存。
4. **权限问题** → 确认 `module.json5` 是否声明相关权限。

## 23.**应用上架运维**

HarmonyOS 应用通过 AppGallery Connect 平台进行上架。流程包括开发者注册、应用创建、打包签名、提交审核和发布。
 审核重点在于权限合规、内容合法以及原子服务规范。
 上架后运维环节主要包括版本管理、崩溃日志监控、性能优化、用户反馈收集和灰度发布。
 另外鸿蒙特别强调 **原子服务** 和 **分布式能力** 的合规性与运维效率。

上架依托 AGC 平台，重点是签名、审核合规与原子服务规范；运维环节侧重版本管理、日志监控、性能优化和灰度发布。

###  1. 应用上架流程

HarmonyOS 应用一般通过 **华为应用市场 (AppGallery Connect, AGC)** 上架，流程与 Android 类似，但有鸿蒙特色：

1. **开发者注册**
   - 个人/企业开发者认证（需实名）。
2. **应用创建**
   - 在 AGC 控制台创建应用，填写应用包名、签名证书、应用信息。
   - 配置应用形态（App / 原子服务 / 卡片服务）。
3. **打包与签名**
   - 使用 DevEco Studio 生成 `.app` 安装包（基于 HAP 打包）。
   - 签名证书由华为开发者平台生成。
4. **提交审核**
   - 上传 `.app` 包，填写应用描述、截图、权限说明。
5. **审核与发布**
   - 华为审核团队检查（功能、隐私合规、内容合法性）。
   - 审核通过 → 发布到应用市场。

------

### 2. 应用审核要点

- **权限合规**：是否合理申请敏感权限（位置信息、摄像头、麦克风等）。
- **分布式能力说明**：涉及设备互联时，需要标注用途。
- **原子服务要求**：体积 < 10MB，功能明确，必须支持 **即点即用**。
- **内容合法**：符合政策法规（内容审核和广告合规）。

------

### 3. 运维与版本管理

上架后，运维环节主要包括：

1. **版本管理**
   - 多 HAP 模块版本控制（Entry HAP、Feature HAP、Shared HAP）。
   - 支持灰度发布（部分用户先行更新）。
2. **日志与监控**
   - **Crash 日志收集**：AGC 崩溃分析服务。
   - **性能监控**：启动时长、卡顿监控、内存/耗电分析。
3. **用户反馈**
   - 应用市场评论、埋点日志。
   - HarmonyOS 提供 `@ohos.hiviewdfx.hilog` 用于日志打印。
4. **更新维护**
   - 支持 **增量更新**，减少包体积。
   - 原子服务可快速迭代，无需用户感知安装。
5. **安全合规**
   - 定期更新隐私协议。
   - 确保数据加密、最小权限原则。

     一次开发，多端部署：
     1.1目标：掌握一次开发多端部署的开发架构设计，合理使用一多界面设计和功能开发要点，使用分层代码架构规范，快速高效的开发支持多种终端设备形态的应用。
     2.自由流转：
   
     2.1目标：帮助开发者了解自由流转中跨端迁移、多端协同的相关体验，了解分布式框架的重要组成部分：分布式软总线、分布式数据、分布式硬件、分布式任务调度，掌握跨端迁移的原理，数据迁移的方式及其适用的场景。
   
     3.应用性能优化：
   
     3.1目标：学习如何使用DevEco Profiler和优化方法来识别和解决应用程序性能问题，提高应用程序的响应速度和吞吐量，减少资源消耗，提升用户体验，包括性能测试和分析、点击响应优化、布局性能优化、资源利用率、稳定性和可靠性等方面。

## 24.鸿蒙中有哪些异步处理方式？分别怎么实现？

HarmonyOS 提供了多种异步机制：

- **Promise/async-await**：最常见的异步写法，语法简洁，适合 API 调用；适合链式异步调用。
- **Callback 回调**：很多系统 API 仍支持回调方式，简单直接，但可读性差；缺点:容易嵌套形成回调地狱
- **Worker 线程**：支持并发任务，将耗时操作放到子线程，避免阻塞 UI；复杂计算、图像处理、数据加密等。
- **TaskDispatcher**：提供任务调度器，可以在不同优先级线程中调度任务，类似 Android 的 Handler；可控性强。
- **事件订阅/响应式数据**：通过状态管理和事件驱动实现 UI 的异步刷新。

实际开发中我会优先用 **async/await + TaskDispatcher**，计算密集型任务则用 **Worker**。

#### HarmonyOS 异步处理机制对比表

| 异步方式                        | API 风格                        | 特点                                  | 适用场景                        | 示例代码                             |
| ------------------------------- | ------------------------------- | ------------------------------------- | ------------------------------- | ------------------------------------ |
| **Promise / async-await**       | `await xxx()`                   | 语法简洁，链式调用，可读性强          | 网络请求、I/O 操作、分布式调用  | `let res = await fetchData();`       |
| **Callback 回调**               | `xxx((err, data)=>{})`          | 传统方式，兼容性好，但可能回调嵌套    | 老 API、简单事件处理            | `fs.readFile(path, (err, data)=>{})` |
| **Worker 子线程**               | `new worker.ThreadWorker()`     | 真正多线程，避免阻塞 UI，数据拷贝传递 | 图像处理、加密运算、数据分析    | `myWorker.postMessage({num:10});`    |
| **TaskDispatcher (任务调度器)** | `asyncDispatch / delayDispatch` | 类似 Android Handler，可指定优先级    | 后台任务、延迟任务、UI 更新调度 | `globalTask.asyncDispatch(()=>{})`   |
| **事件订阅 / 响应式数据**       | `@Observed / EventHub`          | 数据驱动 UI，天然异步更新             | 组件通信、UI 状态管理           | `user.name = "李四"; // 自动刷新`    |

------

#### 25、ArkTs是什么?

ArkTS是HarmonyOS优选的主力应用开发语言。保持了TypeScript的基本风格，同时通过规范定义强化开发期静态检查和分析，提升程序执行稳定性和性能。

ArkTS的主要特点包括：
 **静态类型检查：**ArkTS在编译时进行类型检查，这有助于在代码运行前发现和修复错误，提高代码的稳定性和性能。
 **声明式UI：**ArkTS定义了声明式UI描述，允许开发者以更简洁、更自然的方式开发跨端应用。
 **状态管理：**ArkTS提供了多维度的状态管理机制，使得与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，支持单向和双向数据流。
 **渲染控制：**ArkTS支持条件渲染、循环渲染和数据懒加载，允许开发者根据应用的不同状态渲染UI内容。
 **兼容性：**ArkTS兼容TS/JavaScript生态，开发者可以使用TS/JS进行开发或复用已有代码。
 **并发机制：** ArkTS支持轻量化的并发机制，允许开发者编写并发代码，提高应用的性能和响应速度。

#### 26、ArkTS和TS有什么区别？

ArkTs 基于 Ts 做了扩展，并且强化了静态检查和分析

##### 一、扩展了 UI：

定义了声明式 UI 描述、自定义组件，事件方法、属性方法
 提供了多维度的状态管理机制
 提供了控制渲染、循环渲染的能力

##### 二、强化了检查

不支持 var、any、unknown、Symbol
 不支持解构赋值
 不支持使用对象字面量进行类型声明
 不支持在运行时动态增删对象的属性
 不支持在函数内声明函数
 不支持使用 typeof 作为类型
 不支持使用 # 符号开头声明的私有字段，改用 private 关键字
 不支持把 function 定义函数赋值给变量，改为使用箭头函数

#### 27、Object、object、ESObject有什么区别？

- Object类型是所有引用类型的基类型。任何值，包括基本类型的值（它们会被自动装箱），都可以直接被赋给Object类型的变量。
- object类型则用于表示除基本类型外的类型。
- ESObject类型则用于在ArkTS跨语言调用的场景中，用以标注JS/TS对象的类型

#### 28、Record<K, V>和HashMap<K, V>有什么区别？

Record是一种轻量级的数据结构，主要用于存储一组固定数量的、类型明确的键值对。与HashMap相比，Record的主要特点是不可变性（immutable）和结构化。Record一旦创建，其包含的键值对就不能被修改，这有助于保证数据的完整性和安全性。Record适用于需要在多个组件或方法间传递固定结构数据的场景，例如，传递配置参数或返回结果集。

HashMap则是一种基于哈希表的键值对集合，允许动态添加、删除和更新键值对。通过哈希函数将键映射到值上。适合于快速的键值查找操作，时间复杂度为O(1)。HashMap的主要优点是灵活性高、访问速度快。HashMap适用于需要频繁修改键值对集合的场景，例如，实现缓存或实现自定义的数据结构。HashMap是ArkTS提供的高性能容器类，底层使用红黑树实现，提供了高性能的数据读写操作，适合用于实现快速读写键值。
 Records是用来表示单个数据实体的结构。在HarmonyOS 鸿蒙Next系统中，选择使用Record还是HashMap主要取决于具体的应用场景和需求。如果需要存储和传递固定结构的数据，且不希望数据在传递过程中被修改，那么Record是更好的选择。如果需要动态管理键值对集合，那么HashMap则更为合适。

#### 29、页面和自定义组件生命周期有哪些?

**页面生命周期**，即被@Entry装饰的组件生命周期，提供以下生命周期接口：

- [onPageShow]：页面每次显示时触发一次，包括路由过程、应用进入前台等场景。
- [onPageHide]：页面每次隐藏时触发一次，包括路由过程、应用进入后台等场景。
- [onBackPress]：当用户点击返回按钮时触发。

**组件生命周期**，即一般用@Component装饰的自定义组件的生命周期，提供以下生命周期接口：

- [aboutToAppear]：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。
- [onDidBuild]：组件build()函数执行完成之后回调该接口，开发者可以在这个阶段进行埋点数据上报等不影响实际UI的功能。不建议在onDidBuild函数中更改状态变量、使用animateTo等功能，这可能会导[图片上传失败...(image-f5c490-1742384150320)]
   致不稳定的UI表现。
- [aboutToDisappear]：aboutToDisappear函数在自定义组件析构销毁之前执行。不允许在aboutToDisappear函数中改变状态变量，特别是@Link变量的修改可能会导致应用程序行为不稳定。

#### 30、父子组件如何通信?

##### 父子单向数据传递 @State @Prop

@Prop装饰的变量可以和父组件建立单向的同步关系。@Prop装饰的变量是可变的，但是变化不会同步回其父组件。

##### 父子双向数据传递 @State @Link 、@objectLink @Link

子组件中被 @Link装饰的变量与其父组件中对应的数据源建立双向数据绑定。

##### 跨组件通信 @Provide装饰器和 @Consume装饰器

@Provide和 @Consume，应用于与后代组件的双向数据同步，应用于状态数据在多个层级之间传递的场景。不同于 @Prop和 @Link，@Provide和 @Consume摆脱参数传递机制的束缚，实现跨层级传递。

##### @Observed装饰器和 @ObjectLink装饰器

对于多层嵌套的情况，比如二维数组，或者数组项class，或者class的属性是class，他们的第二层的属性变化是无法观察到的。这就要用到 @Observed/@ObjectLink装饰器

注意:@ObjectLink装饰器不能在 @Entry装饰的自定义组件中使用且 @ObjectLink 装饰的变量不能被赋值,只能对其属性进行赋值操作

#### 31、兄弟组件如何通信?

##### 通过公共父组件传递

如果两个组件是同一个父组件的子组件，可以通过父组件来传递数据或事件。父组件可以作为中介，将一个子组件的数据或事件传递给另一个子组件。

##### 使用全局状态管理

使用全局状态管理（如 AppStorage、LocalStorage）来存储共享数据。兄弟组件可以独立地读取和更新这个全局状态，从而实现通信。

#### 32、如何实现页面间的通信?

使用 @Provide和 @Consume装饰器
 使用路由跳转传参
 使用导航跳转传参

#### 33、跨设备通信的方式有哪些？

HarmonyOS支持多种跨设备通信方式，包括：

- 分布式软总线：一种高性能的通信机制，允许设备之间建立直接连接，进行数据传输。
- 蓝牙：使用标准的蓝牙技术进行设备间的通信。
- WLAN：通过WLAN网络实现设备间的通信。
- 远程服务调用：通过分布式任务调度实现跨设备的服务调用。

#### 34、如何进行全局状态管理?

##### @Provide @Consume装饰器

适用场景：适用于整个组件树而言“全局”的状态共享，且该状态改动不频繁的场景。
 工作原理：通过在最顶层组件中使用 @Provide装饰器提供状态，其他需要共享状态的组件通过 @Consume装饰器获取该状态 。
 优点：减少了状态传递的层级，提升了代码的可维护性和可拓展性。
 注意事项：确保状态的生命周期与组件树的生命周期一致，避免不必要的UI刷新。

##### AppStorage

适用场景：适用于整个应用而言“全局”的变量或应用的主线程内多个 UIAbility实例间的状态共享。
 工作原理：AppStorage与应用的进程绑定，由UI框架在应用程序启动时创建，当应用进程终止，AppStorage被回收。
 优点：适用于需要在整个应用中-共享状态的场景。
 注意事项：确保状态的生命周期与应用进程一致，避免在应用退出后仍有状态存在。

##### LocalStorage

适用场景：适用于单个Ability而言“全局”的变量，主要用于不同页面间的状态共享。
 工作原理：LocalStorage的生命周期由应用程序决定，当应用释放最后一个指向 LocalStorage的引用时，LocalStorage被垃圾回收。
 优点：适用于需要在单个UIAbility中不同页面间共享状态的场景。
 注意事项：确保状态的生命周期与应用程序的生命周期一致，避免在应用退出后仍有状态存在。

#### 35、LocalStorage在应用重启后数据会消失吗?

会,因为LocalStorage 是一种用于页面或组件级别的数据存储方式，它允许开发者在页面或组件的生命周期内存储和检索数据。LocalStorage 的数据存储在内存中，因此它的读写速度相对较快。但是，当应用重启后，LocalStorage 中的数据会丢失。

#### 36、Navigation组件跳转和router跳转有什么区别?

- Navigation：是路由容器组件，适用于模块内和跨模块的路由切换，一次开发，多端部署场景。Router位于页面栈管理节点 stage 下面，不提供导航容器的概念。
- Navigation和 Router都支持跳转传参，但 Router对象中暂不支持方法变量。
- Navigation：支持清理指定路由，页面栈没有上限，可以无限跳转。Router不支持清理指定路由且页面栈最大为32，页面栈到达32之后必须清除之后才能继续跳转。
- Navigation：支持自定义转场动画和共享元素转场动画。 Router：仅支持简单自定义转场动画。
- Navigation：支持通过 setInterception 方法设置路由拦截。Router：不支持路由拦截。
- Navigation：支持沉浸式页面和模态嵌套路由。Router：不支持，需要通过窗口配置实现沉浸式页面。

总而言之，Navigation 组件在功能上更具丰富性和灵活性，特别是在处理复杂的导航结构、动效和路由管理方面。而 Router 则提供了更基础的路由跳转功能，适合简单的路由需求。开发者可以根据应用的具体需求和设计选择最合适的路由方案。

#### 37、什么是Ability？

Ability是应用/服务所具备的能力的抽象，一个Module可以包含一个或多个 Ability ,在鸿蒙系统中，Ability提供了对 Ability生命周期、上下文环境等调用管理的能力，包括 Ability创建、销毁、转储客户端信息等
 鸿蒙系统中的 Ability主要分为两种类型：UIAbility和 ExtensionAbility。

##### UIAbility ：

- 定义 ：包含UI界面，提供展示UI的能力，主要用于和用户交互 。
- 创建 ：在模块中添加UIAbility时，选中对应的模块，单击鼠标右键，选择New > Ability，设置Ability名称，选择是否在设备主屏幕上显示该功能的启动图标，单击Finish完成Ability创建。

##### ExtensionAbility ：

- 定义 ：提供特定场景的扩展能力，满足更多的使用场景 。
- 创建 ：在模块中添加ExtensionAbility时，选中对应的模块，单击鼠标右键，选择不同的场景类型（如Accessibility、EmbeddedUIExtensionAbility等）。当前仅Application工程支持创建ExtensionAbility。设置Ability名称，单击Finish完成ExtensionAbility创建。
   此外，Ability是Ability模块的基类，提供系统配置更新回调和系统内存调整回调。Ability的继承关系包括UIAbility和ExtensionAbility等具体类。

总之，Ability是鸿蒙系统中用于管理应用能力的核心组件，通过不同类型的Ability可以实现不同的功能需求。

#### 38、LazyForEach的工作原理是什么？

- LazyForEach 是一个用于高效渲染列表的组件或功能。
- 它允许开发者在用户滚动列表时才加载和渲染列表项，而不是一次性渲染整个列表。
- 这种按需渲染的方式可以显著提高应用的性能，特别是在处理大量数据时。

LazyForEach 的工作原理通常是基于用户的滚动位置来动态地创建和销毁列表项的组件实例。当用户滚动到列表的某个部分时，LazyForEach 会加载并渲染那些即将进入视图的列表项，同时可能会卸载那些滚出视图的列表项，以节省内存和计算资源。

#### 39、什么是三层工程结构？一次开发，多端部署

- common（公共能力层）：用于存放公共基础能力集合（如工具库、公共配置等）。
   common层可编译成一个或多个HAR包或HSP包（HAR中的代码和资源跟随使用方编译，如果有多个使用方，它们的编译产物中会存在多份相同拷贝；而HSP中的代码和资源可以独立编译，运行时在一个进程中代码也只会存在一份），其只可以被products和features依赖，不可以反向依赖。
- features（基础特性层）：用于存放基础特性集合（如应用中相对独立的各个功能的UI及业务逻辑实现等）。
   各个feature高内聚、低耦合、可定制，供产品灵活部署。不需要单独部署的feature通常编译为HAR包或HSP包，供products或其它feature使用，但是不能反向依赖products层。需要单独部署的feature通常编译为Feature类型的HAP包，和products下Entry类型的HAP包进行组合部署。features层可以横向调用及依赖common层。
- products（产品定制层）：用于针对不同设备形态进行功能和特性集成。
   products层各个子目录各自编译为一个Entry类型的HAP包，作为应用主入口。products层不可以横向调用。

#### 40、如何优化应用的性能？

##### 一、使用并行化、预加载和缓存等方法，提升系统资源利用率，减少主线程负载，加快应用的启动速度和响应速。

使用多线程执行耗时操作
 使用异步执行耗时操作
 使用预加载提升页面启动和响应速度
 使用条件渲染实现预加载
 使用缓存提升启动速度和滑动帧率

##### 二、尽量减少布局的嵌套层数

移除冗余节点，删除无用的Stack/Column/Row嵌套
 使用Column/Row替代Flex构建线性布局
 使用Flex、List、Grid、RelativeContainer、绝对布局和自定义布局等构建复杂布局

##### 三、合理管理状态变量

合理管理状态变量，减少不必要的参数层次传递
 避免滥用@Provide+@Consume
 控制对象级状态变量成员数量
 避免不必要的创建和读取状态变量

##### 四、合理使用系统接口，避免冗余操作

避免在系统高频调用进行冗余和耗时操作
 避免在系统高频调用打印日志
 在Release版本中删除Debug日志

##### 五、使用性能工具分析和定位问题

**41. 应用切到后台后，如何保证任务继续进行？** 在鸿蒙应用开发中，当应用切到后台后，系统会对应用进行一定的管控，以优化资源利用和用户体验。为保证任务在后台继续进行，可采用以下方式：

申请后台任务权限，需要配置权限ohos.permission.KEEP_BACKGROUND_RUNNING：

或者使用服务（Service）组件。

**42. UIAbility和Page以及组件的生命周期函数** UIAbility 有 onCreate、onWindowStageCreate 等生命周期函数用于自身创建、窗口阶段创建等阶段。 Page 有 onPageShow、onPageHide 等函数处理页面显示与隐藏等情况，aboutToAppear等。 组件则有自身从创建到销毁过程中的如 init、build、delete 等生命周期函数来管理其状态和渲染等操作。

**43. router和Navigaiton的区别是什么？** 在鸿蒙开发里，Router 和 Navigation 虽都用于页面导航，但存在明显差异。Router 功能基础，侧重于简单的页面切换，支持通过 URL 跳转，页面间数据传递需手动处理，适用于页面结构和导航逻辑简单的场景，因功能轻量，在简单场景下性能开销小、导航速度快，使用时主要调用 Router.pushUrl 方法；而 Navigation 功能更丰富，支持栈管理和便捷的返回数据处理，适合复杂导航及需处理返回数据的场景，不过因管理页面栈等操作性能开销稍大。

**44. 数据临时和持久存储技术方案是什么？** 数据临时存储可使用内存变量，在程序运行期间保存数据，应用关闭或进程被杀时数据丢失；还能利用函数内部的局部变量实现临时存储。而数据持久存储方面，可采用 LocalStorage，它能在本地存储数据，即使应用关闭或进程被杀，数据依然保留，存储容量有限，约 5 - 10 兆；APP Storage 也是常用方案，它存储无限制，数据存于沙箱，仅卸载应用时数据才被清除；此外，还能借助数据库，如关系型数据库或轻量级的文件数据库，来高效管理和持久存储结构化数据，满足复杂数据存储和查询需求。

**45. 悬浮球如何实现？** 在纯血鸿蒙中实现悬浮球，可先在配置文件里声明所需权限，如窗口显示相关权限。接着创建自定义组件作为悬浮球的 UI，设置其样式，如大小、颜色、形状等。通过系统提供的窗口管理 API 创建一个悬浮窗口，将自定义的悬浮球组件添加到该窗口中。为实现悬浮球的移动功能，要监听触摸事件，根据触摸点的坐标变化更新悬浮球的位置。同时可添加点击、长按等交互事件处理逻辑，例如点击时弹出菜单、长按可进行拖动等。最后，对悬浮球的显示和隐藏进行控制，比如在特定条件下隐藏或显示悬浮球，确保在不同场景下都能合理使用。

**46. 鸿蒙应用的进程和线程** 参考：[【HarmonyOS Next】鸿蒙应用进程和线程详解](https://blog.csdn.net/superherowupan/article/details/145732735)

进程是系统进行资源分配和调度的基本单位，每个鸿蒙应用至少有一个主进程，应用启动时系统会为其分配进程资源。应用可通过配置文件声明多进程，以实现不同功能模块的隔离，提高应用的稳定性和性能，比如将数据处理、网络请求等操作放在独立进程中。线程则是进程内的执行单元，一个进程可包含多个线程。主进程中有主线程负责处理 UI 渲染和用户交互，为避免阻塞主线程导致界面卡顿，耗时操作如网络请求、文件读写等需放在子线程中执行，可使用鸿蒙提供的线程池、异步任务框架等实现多线程编程，合理利用线程能充分发挥设备多核性能，提升应用响应速度和整体性能。

**47. 鸿蒙应用如何实现子线程？** 参考：[【HarmonyOS Next】鸿蒙TaskPool和Worker详解 （一）](https://blog.csdn.net/superherowupan/article/details/145883291)

**48. worker和taskPool的区别** 任务池（taskpool）：任务池为应用程序提供一个多线程的运行环境。它主要用于处理耗时的计算任务或其他密集型任务，可以有效地避免这些任务阻塞主线程。这样不仅能最大化系统的利用率，还能降低整体资源的消耗并提高系统的整体性能。 Promise是一种用于处理异步操作的对象。它代表了一个最终可能完成（或失败）的操作及其结果值的对象。与任务池不同，Promise主要用于处理异步操作，而不是多线程计算任务。

**49. webview如何和原生双向通信？** runJavaScript：异步执行JavaScript脚本，并通过回调方式返回脚本执行的结果。 onConfirm：网页调用confirm()告警时触发此回调。 或在h5注册map与回调，通过调用注册的回调方法向ArkTS侧传递数据

**50.forEach与LazyforEach 还有repeat的使用与区别？** 参考：[ 【HarmonyOS Next】鸿蒙循环渲染ForEach，LazyForEach，Repeat使用心得体会](https://blog.csdn.net/superherowupan/article/details/145827023)

**51.折叠屏如何适配，方案有哪些？** 布局适配方面，可采用响应式布局，利用弹性容器、百分比和媒体查询等技术，使界面元素能依据屏幕尺寸与比例自动调整大小和位置；采用多窗口布局，针对不同折叠状态提供不同的布局方案，如单屏、分屏等模式。资源适配时，需准备多套不同分辨率和尺寸的图片、图标等资源，以便系统根据屏幕情况加载合适的资源。交互适配要考虑不同折叠形态下用户的操作习惯变化，例如在大屏模式下支持多任务操作、手势操作等；同时，为避免因屏幕折叠引发数据丢失或异常，需做好状态保存与恢复，在屏幕折叠前后保存和恢复应用的关键数据、界面状态等。此外，还可进行性能优化，合理分配资源，避免在折叠屏设备上出现性能瓶颈。

Navigaiton分栏，全屏自适应➕布局宽高监听➕子窗口变化监听 栅栏布局➕设备媒体查询。

**52.鸿蒙如何打包插件和应用？** 打包应用时，首先要确保项目代码开发完成且无错误，在 DevEco Studio 里，通过配置 config.json 文件明确应用的基本信息、权限需求等；接着，选择合适的构建方式，可使用 Studio 自带的构建工具，按提示完成签名配置，包括选择签名类型、创建或导入密钥等；最后执行构建任务，系统会生成 .hap（HarmonyOS Ability Package）或 .app 格式的应用安装包。而打包插件，若为 HSP（HarmonyOS Service Package）插件，同样先完善代码开发，在 config.json 里对插件进行详细配置，明确插件类型、入口文件等信息；之后进行编译操作，完成签名后即可生成 .hsp 格式的插件包。无论打包应用还是插件，都要确保配置准确、签名合规，以保证能正常安装和使用。
