# 一、一多开发&项目搭建

今日核心:一多开发项目搭建

 

# 1. 应用开发准备

## 1.1. 注册成为开发者

在华为开发者联盟网站上，[注册成为开发者](https://developer.huawei.com/consumer/cn/doc/start/registration-and-verification-0000001053628148)，并完成[实名认证](https://developer.huawei.com/consumer/cn/doc/start/rna-0000001062530373)，从而享受联盟开放的各类能力和服务，通过实名认证之后的管理中心如下图所示：

https://developer.huawei.com/consumer/cn/

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1714028250007-8adc2ee2-8378-434b-9e3e-e00d8322b077.png)

## 1.2. 在AGC平台创建项目和创建应用

[华为提供的面向开发者的应用一站式服务平台](https://developer.huawei.com/consumer/cn/service/josp/agc/index.html#/)

1- 创建项目：名字根据情况自行调整

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717381330600-6c311ad4-22c0-41a7-aae9-9303fda694f4.png)



2- 在项目中创建应用

![img](https://cdn.nlark.com/yuque/0/2024/png/274425/1714042715468-fe1a6075-975b-4d11-a592-1e029cc4c18d.png)



![img](https://cdn.nlark.com/yuque/0/2024/png/38706227/1723964382020-fa7b3162-8ce5-4934-8854-451a739f08d8.png)

![img](https://cdn.nlark.com/yuque/0/2024/png/38706227/1723964493702-2036cda2-3982-469e-8615-9462d256bc91.png)

开放能力: 

![img](https://cdn.nlark.com/yuque/0/2025/png/38706227/1742731799387-fad8dc04-4953-4ced-9bdf-21a21683d0fc.png)

记住这个项目的名称，比如：

项目名称: 美优购商城

包名: com.itcast.myg_mall





# 2. 一多开发

[链接](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/introduction-V5)

“一次开发、多端部署”简称“一多”：一套代码工程，一次开发上架，多端按需部署。

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717126239558-99b91625-ad3a-4e50-a5d2-9c345301ad92.png)为了实现这个目标，主要解决 3 个核心问题：

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717126404552-86b1ce20-7e84-4893-a336-3f416a6ec755.png)

1. 页面适配问题：界面级一多（**重点掌握**）
2. 功能兼容问题：功能级一多（了解）
3. 工程如何组织：工程级一多（**重点掌握**）

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717127403531-8c32e0ff-9ba2-43e6-bb1c-d0233ce05bdd.png)

1(HarmonyOS) + 8(手机/平板/电脑/2in1/手表/车机/电视/...) + N(其它只能设备)

# 3. 界面级一多能力（掌握）

[链接](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/layout-intro.md)

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717126752256-54cb08f4-22b1-46b3-a67a-276bb0e78e0c.png)![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717126768338-f62ddbf3-c40c-4e34-b710-80c1621c3c5f.png)![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717126787299-0c041af2-e65d-448d-a87c-6ebd4162abb6.png) 

界面级一多能力有 2 类：

1. 自适应布局:   略微调整界面结构
2. 响应式布局：比较大的界面调整

## 3.1. 自适应布局

[自适应布局](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/adaptive-layout.md)

自适应布局的能力有 7 种,主要解决的是：窗口尺寸在【一定范围内】变化时，页面能够正常显示

| **自适应布局能力**                                           | **使用场景**                                                 | **实现方式**                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| [拉伸能力](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/adaptive-layout.md#拉伸能力) | 容器组件尺寸发生变化时，增加或减小的空间**全部分配**给容器组件内**指定区域**。 | [Flex布局](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-universal-attributes-flex-layout.md)的flexGrow和flexShrink属性 |
| [均分能力](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/adaptive-layout.md#均分能力) | 容器组件尺寸发生变化时，增加或减小的空间**均匀分配**给容器组件内**所有空白区域**。 | [Row组件](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-container-row.md)、[Column组件](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-container-column.md)或[Flex组件](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-container-flex.md)的justifyContent属性设置为FlexAlign.SpaceEvenly |
| [占比能力](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/adaptive-layout.md#占比能力) | 子组件的宽或高**按照预设的比例**，随容器组件发生变化。       | 基于通用属性的两种实现方式： - 将子组件的宽高设置为父组件宽高的百分比 - layoutWeight属性 |
| [缩放能力](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/adaptive-layout.md#缩放能力) | 子组件的宽高**按照预设的比例**，随容器组件发生变化，且变化过程中子组件的**宽高比不变**。 | [布局约束](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-universal-attributes-layout-constraints.md)的aspectRatio属性 |
| [延伸能力](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/adaptive-layout.md#延伸能力) | 容器组件内的子组件，按照其**在列表中的先后顺序**，随容器组件尺寸变化显示或隐藏。 | 基于容器组件的两种实现方式： - 通过[List组件](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-container-list.md)实现 - 通过[Scroll组件](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-container-scroll.md)配合[Row组件](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-container-row.md)或[Column组件](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-container-column.md)实现 |
| [隐藏能力](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/adaptive-layout.md#隐藏能力) | 容器组件内的子组件，按照其**预设的显示优先级**，随容器组件尺寸变化显示或隐藏。**相同显示优先级的子组件同时显示或隐藏**。 | [布局约束](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-universal-attributes-layout-constraints.md)的displayPriority属性 |
| [折行能力](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/adaptive-layout.md#折行能力) | 容器组件尺寸发生变化时，如果布局方向尺寸不足以显示完整内容，**自动换行**。 | [Flex组件](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-container-flex.md)的wrap属性设置为FlexWrap.Wrap |

### 3.1.1. 拉伸能力

[Flex布局](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-universal-attributes-flex-layout.md)

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717128009103-ae4c3988-9d6f-49b8-90c5-a8cd87e146f0.png)

拉伸能力指的是容器尺寸发生变化时：将变化的空间，分配给容器内的【指定区域】。利用的是 2 个属性:

| **属性名** | **类型** | **必填** | **说明**                                                     |
| ---------- | -------- | -------- | ------------------------------------------------------------ |
| flexGrow   | number   | 是       | 设置父容器在主轴方向上的剩余空间分配给此属性所在组件的比例。 默认值：0 |
| flexShrink | number   | 是       | 设置父容器压缩尺寸分配给此属性所在组件的比例。 父容器为[Column](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-container-column.md)、[Row](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-container-row.md)时，默认值：0 父容器为[Flex](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-container-flex.md)时，默认值：1 |

需求：

​    1. 空间不足时：分配给左右，1：1

​    2. 空间富余时：分配给中间

**测试代码:**

```ts
@Entry
@Component
struct Demo01 {
  // 绑定的宽度-默认 600
  @State containerWidth: number = 600

  // 底部滑块，可以通过拖拽滑块改变容器尺寸。
  @Builder
  sliderBuilder() {
    Slider({
      value: this.containerWidth, // 绑定的值
      min: 400, // 最小值
      max: 1000, // 最大值
      style: SliderStyle.OutSet // 滑块在滑轨上
    })
      .blockColor(Color.White)
      .width('60%')
      .position({ x: '20%', y: '80%' })
      .onChange((value)=>{
        this.containerWidth = value
      })
  }

  build() {
    Stack({ alignContent: Alignment.TopStart }) {
      // 标记现在的宽度
      Text('宽度:' + this.containerWidth)
        .zIndex(2)
        .translate({ x: 20, y: 20 })
        .fontColor(Color.Orange)

      // 核心区域
      Column() {
        Column() {
          Row() {
            // 布局能l力 1：拉伸能力：
            // 容器组件尺寸发生改变时，将变化的部分分配给容器内的【指定区域】
            //

            // 涉及属性：
            // flexShrink:压缩比例，默认值：Column，Row 时（0），Flex 时（1）
            // flexGrow:拉伸比例，默认值 0

            // 需求：
            // 1. 空间不足时：分配给左右，1：1
            // 2. 空间富余时：分配给中间

            // 左
            Row() {
              Text('左')
                .fontSize(20)
                .fontColor(Color.White)
            }
            .justifyContent(FlexAlign.Center)
            .width(150)
            .height(290)
            .backgroundColor('#c2baa6')

            // 中
            Row() {
              Text('中')
                .fontSize(30)
                .fontColor(Color.White)
            }
            .width(300)
            .height(290)
            .backgroundColor('#68a67d')
            .justifyContent(FlexAlign.Center)


            // 右
            Row() {
              Text('右')
                .fontSize(20)
                .fontColor(Color.White)
            }
            .justifyContent(FlexAlign.Center)
            .width(150)
            .height(290)
            .backgroundColor('#c2baa6')

          }
          .width(this.containerWidth)
          .justifyContent(FlexAlign.Center)
          .alignItems(VerticalAlign.Center)
          .border({ width: 2, color: Color.Orange })
          .backgroundColor(Color.Black)
        }

        // 底部滑块
        this.sliderBuilder()
      }
      .width('100%')
      .height('100%')
      .backgroundColor(Color.Pink)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    }
  }
}
@Entry
@Component
struct Demo01 {
  // 绑定的宽度-默认 600
  @State containerWidth: number = 600

  // 底部滑块，可以通过拖拽滑块改变容器尺寸。
  @Builder
  sliderBuilder() {
    Slider({
      value: this.containerWidth, // 绑定的值
      min: 400, // 最小值
      max: 1000, // 最大值
      style: SliderStyle.OutSet // 滑块在滑轨上
    })
      .blockColor(Color.White)
      .width('60%')
      .position({ x: '20%', y: '80%' })
      .onChange((value)=>{
        this.containerWidth = value
      })
  }

  build() {
    Stack({ alignContent: Alignment.TopStart }) {
      // 标记现在的宽度
      Text('宽度:' + this.containerWidth)
        .zIndex(2)
        .translate({ x: 20, y: 20 })
        .fontColor(Color.Orange)

      // 核心区域
      Column() {
        Column() {
          Row() {
            // 左
            Row() {
              Text('左')
                .fontSize(20)
                .fontColor(Color.White)
            }
            .justifyContent(FlexAlign.Center)
            .width(150)
            .height(290)
            .backgroundColor('#c2baa6')
            .flexShrink(1)

            // 中
            Row() {
              Text('中')
                .fontSize(30)
                .fontColor(Color.White)
            }
            .width(300)
            .height(290)
            .backgroundColor('#68a67d')
            .justifyContent(FlexAlign.Center)
            .flexGrow(1)


            // 右
            Row() {
              Text('右')
                .fontSize(20)
                .fontColor(Color.White)
            }
            .justifyContent(FlexAlign.Center)
            .width(150)
            .height(290)
            .backgroundColor('#c2baa6')
            .flexShrink(1)

          }
          .width(this.containerWidth)
          .justifyContent(FlexAlign.Center)
          .alignItems(VerticalAlign.Center)
          .border({ width: 2, color: Color.Orange })
          .backgroundColor(Color.Black)
        }

        // 底部滑块
        this.sliderBuilder()
      }
      .width('100%')
      .height('100%')
      .backgroundColor(Color.Pink)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    }
  }
}
```

### 3.1.2. 均分能力

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717128289293-407d678a-1653-4bd8-9ba7-ed8f25bc3c03.png)

均分能力指的是容器尺寸发生变化时：将变化的空间，【均匀分配】给容器组件内【空白区域】。利用的是一个属性justifyContent，只能用在容器：**Flex**、**Column**、**Row** 上，将他设置为 **SpaceEvenly**即可

| **枚举名称**    | **描述**                                                     |
| --------------- | ------------------------------------------------------------ |
| Start           | 元素在主轴方向首端对齐，第一个元素与行首对齐，同时后续的元素与前一个对齐。 |
| Center          | 元素在主轴方向中心对齐，第一个元素与行首的距离与最后一个元素与行尾距离相同。 |
| End             | 元素在主轴方向尾部对齐，最后一个元素与行尾对齐，其他元素与后一个对齐。 |
| SpaceBetween    | Flex主轴方向均匀分配弹性元素，相邻元素之间距离相同。第一个元素与行首对齐，最后一个元素与行尾对齐。 |
| SpaceAround     | Flex主轴方向均匀分配弹性元素，相邻元素之间距离相同。第一个元素到行首的距离和最后一个元素到行尾的距离是相邻元素之间距离的一半。 |
| **SpaceEvenly** | Flex主轴方向均匀分配弹性元素，相邻元素之间的距离、第一个元素与行首的间距、最后一个元素到行尾的间距都完全一样。 |

**测试代码:**

```ts
export interface NavItem {
  id: number
  icon: ResourceStr
  title: string
}

@Entry
@Component
struct Demo02 {
  readonly list: NavItem [] = [
    { id: 1, icon: $r('app.media.ic_nav_01'), title: '淘金币' },
    { id: 2, icon: $r('app.media.ic_nav_02'), title: '摇现金' },
    { id: 3, icon: $r('app.media.ic_nav_03'), title: '闲鱼' },
    { id: 4, icon: $r('app.media.ic_nav_04'), title: '中通快递' },
  ]
  @State rate: number = 600

  // 底部滑块，可以通过拖拽滑块改变容器尺寸
  @Builder
  sliderBuilder() {
    Slider({
      value: this.rate,
      min: 200,
      max: 600,
      style: SliderStyle.OutSet
    })
      .blockColor(Color.White)
      .width('60%')
      .position({ x: '20%', y: '80%' })
      .onChange((value)=>{
        this.rate = value
      })
  }

  build() {
    Stack({ alignContent: Alignment.TopStart }) {
      // 标记现在的宽度
      Text('宽度:' + this.rate.toFixed(0))
        .zIndex(2)
        .translate({ x: 20, y: 20 })
        .fontColor(Color.Orange)

      Column() {
        Column() {
          // 布局能力 2：均分能力
          // 指容器组件尺寸发生变化时，增加或减小的空间均匀分配给容器组件内所有【空白区域】。
          // 常用于内容数量固定、均分显示的场景，比如工具栏、底部菜单栏、导航栏等

          // 涉及属性:
          // Row、Column、Flex 组件的 justifyContent 属性
          // justifyContent设置为 FlexAlign.SpaceEvenly即可
          Row() {
            ForEach(this.list, (item: NavItem) => {
              Column() {
                Image(item.icon)
                  .width(48)
                  .height(48)
                  .margin({ top: 8 })
                Text(item.title)
                  .width(64)
                  .height(30)
                  .lineHeight(15)
                  .fontSize(12)
                  .textAlign(TextAlign.Center)
                  .margin({ top: 8 })
                  .padding({ bottom: 15 })
              }
              .width(80)
              .height(102)
              .backgroundColor('#8FBF9F')
              .borderRadius(10)
            })
          }
          .width('100%')
          .justifyContent(FlexAlign.SpaceEvenly)

        }
        .width(this.rate) // 绑定滑块改变的尺寸
        .padding({ top: 16 })
        .backgroundColor(Color.Pink)
        .borderRadius(16)


        this.sliderBuilder()
      }
      .width('100%')
      .height('100%')
      .backgroundColor('#F1F3F5')
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
    }
  }
}
```

### 3.1.3. 占比能力

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717138371189-f9076bd3-d35f-4114-8c42-71bebcd1651a.png)

占比能力是指子组件的【宽高】按照【预设的比例】，随父容器组件发生变化。实现的方式有 2 种：

1. 宽高设置为百分比
2. 设置layoutWeight

| **属性名**   | **类型**                                                     | **必填** | **说明**                                                     |
| ------------ | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ |
| width        | [Length](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-types.md#length) | 是       | 要设置的组件宽度。 单位：vp                                  |
| height       | [Length](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/reference/apis-arkui/arkui-ts/ts-types.md#length) | 是       | 要设置的组件高度。 单位：vp                                  |
| layoutWeight | number \| string                                             | 是       | 父容器尺寸确定时，设置了layoutWeight属性的子元素与兄弟元素占主轴尺寸按照权重进行分配，忽略元素本身尺寸设置，表示自适应占满剩余空间。 默认值：0 **说明：** 仅在Row/Column/Flex布局中生效。 可选值为大于等于0的数字，或者可以转换为数字的字符串。 |

**测试代码：**

```ts
@Entry
@Component
struct Demo03 {
  @State rate: number = 200

  // 底部滑块，可以通过拖拽滑块改变容器尺寸
  @Builder
  slider() {
    Slider({
      value: this.rate,
      min: 200,
      max: 500,
      style: SliderStyle.OutSet
    })
      .blockColor(Color.White)
      .width('60%')
      .height(50)
      .position({ x: '20%', y: '80%' })
      .onChange((value)=>{
        this.rate = value
      })
  }

  build() {
    Stack({ alignContent: Alignment.TopStart }) {
      // 显示目前容器的宽度
      Text('宽度:' + this.rate.toFixed(0))
        .zIndex(2)
        .translate({ x: 20, y: 20 })
        .fontColor(Color.Orange)


      Column() {
        // 布局能力 3：占比能力
        // 子组件的宽高按照预设的比例，随父容器组件发生变化

        // 实现方式：
        // 1. 子组件的【宽高】设置为父组件宽高的【百分比】
        // 2. 通过 layoutWeight 属性设置主轴方向【布局权重】（比例）


        // 容器 主轴横向
        Row() {
          // 上一首
          Column() {
            Image($r("app.media.ic_public_play_last"))
              .width(50)
              .height(50)
              .border({ width: 2 })
              .borderRadius(30)
              .padding(10)

          }
          .height(96)
          .justifyContent(FlexAlign.Center)
          .alignItems(HorizontalAlign.Center)
           // .width('34%')
          .layoutWeight(1)



          // 播放&暂停
          Column() {
            Image($r("app.media.ic_public_pause"))
              .width(50)
              .height(50)
              .border({ width: 2 })
              .borderRadius(30)
              .padding(10)
          }
          .height(96)
          .backgroundColor(Color.Red)
          .justifyContent(FlexAlign.Center)
          .alignItems(HorizontalAlign.Center)
           // .width('34%')
          .layoutWeight(1)



          // 下一首
          Column() {
            Image($r("app.media.ic_public_play_next"))
              .width(50)
              .height(50)
              .border({ width: 2 })
              .borderRadius(30)
              .padding(10)
          }
          .height(96)
          .justifyContent(FlexAlign.Center)
          .alignItems(HorizontalAlign.Center)
           // .width('34%')
          .layoutWeight(1)

        }
        .width(this.rate) // 绑定宽度给 容器
        .height(96)
        .borderRadius(16)
        .backgroundColor(Color.Pink)

        // 调整宽度的滑块
        this.slider()
      }
      .width('100%')
      .height('100%')
      .backgroundColor('#F1F3F5')
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
    }
  }
}
```



### 3.1.4. 缩放能力

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717138393383-3168f3c9-2fa1-4bf5-8518-219fef866c0b.png)

缩放能力是指子组件的【宽高】按照预设的比例，随容器组件发生变化，变化过程中子组件的【宽高比不变】。使用的属性是  aspectRatio

| **属性名**  | **类型** | **必填** | **说明**                                                     |
| ----------- | -------- | -------- | ------------------------------------------------------------ |
| aspectRatio | number   | 是       | 指定当前组件的宽高比，aspectRatio = width/height。 API version 9及以前，默认值为：1.0。 API version 10：无默认值。 **说明：** 该属性在不设置值或者设置非法值时不生效。 例如，Row只设置宽度且没有子组件，aspectRatio不设置值或者设置成负数时，此时Row高度为0。长宽比 |

**测试代码：**

```ts
@Entry
@Component
struct Demo04 {
  @State sliderWidth: number = 400
  @State sliderHeight: number = 400

  // 底部滑块，可以通过拖拽滑块改变容器尺寸
  @Builder
  slider() {

    Slider({
      value: this.sliderHeight,
      min: 100,
      max: 400,
      style: SliderStyle.OutSet
    })
      .blockColor(Color.White)
      .width('60%')
      .height(50)
      .position({ x: '20%', y: '80%' })
      .onChange((value)=>{
        this.sliderHeight = value
      })

    Slider({
      value: this.sliderWidth,
      min: 100,
      max: 400,
      style: SliderStyle.OutSet
    })
      .blockColor(Color.White)
      .width('60%')
      .height(50)
      .position({ x: '20%', y: '87%' })
      .onChange((value)=>{
        this.sliderWidth = value
      })
  }

  build() {
    Stack({ alignContent: Alignment.TopStart }) {
      Text('宽度:' + this.sliderWidth.toFixed(0) + ' 高度:' + this.sliderHeight.toFixed(0))
        .zIndex(2)
        .translate({ x: 20, y: 20 })
        .fontColor(Color.Orange)
      Column() {
        // 动态修改该容器的宽高
        Column() {
          Column() {
            Image($r("app.media.avatar"))
              .width('100%')
              .height('100%')
          }
          .border({ width: 2, color: Color.Red }) // 边框，仅用于展示效果
          // 布局能力 4：缩放能力
          // 子组件的宽高按照预设的比例，随容器组件发生变化，且变化过程中子组件的【宽高比】不变。

          // 实现方式：
          // 给子组件设置 aspectRatio即可 设置的值是 宽度/高度

        }
        .backgroundColor(Color.Gray)
        .height(this.sliderHeight)
        .width(this.sliderWidth)
        .justifyContent(FlexAlign.Center)
        .alignItems(HorizontalAlign.Center)

        this.slider()
      }
      .width('100%')
      .height('100%')
      .backgroundColor("#F1F3F5")
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
    }

  }
}
```

### 3.1.5. 延伸能力

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717138424109-3bb017b5-d6a0-4e2a-8133-cc3b512df576.png)

延伸能力是指容器组件内的子组件，按照其在列表中的先后顺序，随容器组件尺寸变化【显示或隐藏】，隐藏时可以通过滑动切换显示。实现的方式是通过 List 组件或 Scroll 组件

  **.listDirection(Axis.Horizontal)**

**Scroll() {}.   // .scrollable(ScrollDirection.Horizontal) // 设置横向滚动**

**测试代码：**

```ts
import { NavItem } from './Demo02'


@Entry
@Component
struct Demo05 {
  @State rate: number = 100
  // 数组
  readonly appList: NavItem [] = [
    { id: 1, icon: $r('app.media.ic_nav_01'), title: '淘金币' },
    { id: 2, icon: $r('app.media.ic_nav_02'), title: '摇现金' },
    { id: 3, icon: $r('app.media.ic_nav_03'), title: '闲鱼' },
    { id: 4, icon: $r('app.media.ic_nav_04'), title: '中通快递' },
    { id: 5, icon: $r('app.media.ic_nav_05'), title: '芭芭农场' },
    { id: 6, icon: $r('app.media.ic_nav_06'), title: '淘宝珍库' },
    { id: 7, icon: $r('app.media.ic_nav_07'), title: '阿里拍卖' },
    { id: 8, icon: $r('app.media.ic_nav_08'), title: '阿里药房' },
  ]

  // 底部滑块，可以通过拖拽滑块改变容器尺寸
  @Builder
  slider() {
    Slider({
      value: this.rate,
      min: 100,
      max: 730,
      style: SliderStyle.OutSet
    })
      .blockColor(Color.White)
      .width('60%')
      .height(50)
      .position({ x: '20%', y: '80%' })
      .onChange((value)=>{
        this.rate = value
      })
  }

  build() {
    Stack({ alignContent: Alignment.TopStart }) {
      // 展示宽度
      Text('宽度:' + this.rate.toFixed(0))
        .zIndex(2)
        .translate({ x: 20, y: 20 })
        .fontColor(Color.Orange)

      Column() {
        Row({ space: 10 }) {
          // 布局能力 5：延伸能力
          // 容器组件内的子组件，按照其在列表中的先后顺序，随容器组件尺寸变化【显示或隐藏】

          // 实现方式：
          // 1.List 组件
          // 2.Scroll 配合 Row 或者 Column
          // 核心：调整父容器的尺寸，让页面中显示的组件数量发生改变

          // 通过List组件实现隐藏能力
          List({ space: 10 }) {
            ForEach(this.appList, (item: NavItem) => {
              ListItem() {
                Column() {
                  Image(item.icon)
                    .width(48)
                    .height(48)
                    .margin({ top: 8 })
                  Text(item.title)
                    .width(64)
                    .height(30)
                    .lineHeight(15)
                    .fontSize(12)
                    .textAlign(TextAlign.Center)
                    .margin({ top: 8 })
                    .padding({ bottom: 15 })
                }
                .width(80)
                .height(102)
              }
              .width(80)
              .height(102)
            })
          }
          .padding({ top: 16, left: 10 })
          .listDirection(Axis.Horizontal)
          .width('100%')
          .height(118)
          .borderRadius(16)
          .backgroundColor(Color.White)

          // 通过Scroll 组件实现隐藏能力
          // Scroll() {
          //   Row({ space: 10 }) {
          //     ForEach(this.appList, (item: NavItem, index: number) => {
          //       Column() {
          //         Image(item.icon)
          //           .width(48)
          //           .height(48)
          //           .margin({ top: 8 })
          //         Text(item.title)
          //           .width(64)
          //           .height(30)
          //           .lineHeight(15)
          //           .fontSize(12)
          //           .textAlign(TextAlign.Center)
          //           .margin({ top: 8 })
          //           .padding({ bottom: 15 })
          //       }
          //       .width(80)
          //       .height(102)
          //     })
          //   }
          // }
          // .scrollable(ScrollDirection.Horizontal) // 设置横向滚动
          // .padding({ top: 16, left: 10 })
          // .height(118)
          // .borderRadius(16)
          // .backgroundColor(Color.White)
        }
        .width(this.rate)

        this.slider()
      }
      .width('100%')
      .height('100%')
      .backgroundColor(Color.Pink)
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
    }

  }
}
```



### 3.1.6. 隐藏能力

隐藏能力指的是：按其【显示优先级】，随容器组件尺寸变化显示或隐藏。通过**displayPriority**属性来实现  

显示优先级

等级一样一起显示    全部都要设置优先级  值越大1优先级越高

| **属性名**      | **类型** | **必填** | **说明**                                                     |
| --------------- | -------- | -------- | ------------------------------------------------------------ |
| displayPriority | number   | 是       | 设置当前组件在布局容器中显示的优先级，当父容器空间不足时，**低优先级的组件会被隐藏**。 小数点后的数字不作优先级区分，即区间为[x, x + 1)内的数字视为相同优先级。例如：1.0与1.9为同一优先级。 **说明：** 仅在Row/Column/Flex(单行)容器组件中生效。 |

**测试代码：**

```ts
@Entry
@Component
struct Demo06 {
  @State rate: number = 48

  // 底部滑块，可以通过拖拽滑块改变容器尺寸
  @Builder
  slider() {
    Slider({
      value: this.rate,
      min: 0,
      max: 400,
      style: SliderStyle.OutSet
    })
      .blockColor(Color.White)
      .width('60%')
      .height(50)
      .position({ x: '20%', y: '80%' })
      .onChange((value)=>{
        this.rate = value
      })
  }

  build() {
    Stack({ alignContent: Alignment.TopStart }) {
      Text('宽度:' + this.rate.toFixed(0))
        .zIndex(2)
        .translate({ x: 20, y: 20 })
        .fontColor(Color.Orange)

      Column() {
        // 布局能力 6：隐藏能力
        // 容器组件内的子组件，按照其预设的显示优先级，随容器组件尺寸变化显示或隐藏

        // 实现方式：
        // displayPriority属性：设置布局优先级来控制显隐
        // 当主轴方向剩余尺寸不足以满足全部元素时，按照布局优先级，从[小到大]依次隐藏


        Row({ space: 10 }) {
          Image($r("app.media.ic_public_favor"))
            .width(48)
            .height(48)


          Image($r("app.media.ic_public_play_last"))
            .width(48)
            .height(48)


          Image($r("app.media.ic_public_pause"))
            .width(48)
            .height(48)


          Image($r("app.media.ic_public_play_next"))
            .width(48)
            .height(48)
            .objectFit(ImageFit.Contain)


          Image($r("app.media.ic_public_view_list"))
            .width(48)
            .height(48)
            .objectFit(ImageFit.Contain)

        }
        .width(this.rate)
        .height(96)
        .borderRadius(16)
        .backgroundColor(Color.Gray)
        .justifyContent(FlexAlign.Center)
        .padding(10)

        this.slider()
      }
      .width('100%')
      .height('100%')
      .backgroundColor('#F1F3F5')
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
    }

  }
}
@Entry
@Component
struct DisplayCase {
  @State message: string = 'Hello World';

  build() {
    Row() {
     Image($r("sys.media.waveform_folder_fill"))
        .width(100)
        .aspectRatio(1)
       .displayPriority(1)

      Image($r("sys.media.rectangle_filled_and_line_horizontal_and_rectangle"))
        .width(100)
        .aspectRatio(1)
        .displayPriority(2)
      Image($r("sys.media.ohos_user_auth_icon_face"))
        .width(100)
        .aspectRatio(1)
        .displayPriority(3)
      Image($r("sys.media.phone_arrow_down_left_circle_fill"))
        .width(100)
        .aspectRatio(1)
        .displayPriority(2)
      Image($r("sys.media.ohos_save_button_filled"))
        .width(100)
        .aspectRatio(1)
        .displayPriority(1)
    }
    .justifyContent(FlexAlign.SpaceEvenly)
    .height('100%')
    .width('100%')
  }
}
```



### 3.1.7. 折行能力

折行能力是指容器组件尺寸发生变化，当布局方向尺寸不足以显示完整内容时自动换行。折行能力通过使用 **Flex折行布局** （将wrap属性设置为**FlexWrap.Wrap**）实现。

**wrap: FlexWrap.Wrap**

| **名称**    | **描述**                                          |
| ----------- | ------------------------------------------------- |
| NoWrap      | Flex容器的元素单行/列布局，子项不允许超出容器。   |
| **Wrap**    | Flex容器的元素多行/列排布，子项允许超出容器。     |
| WrapReverse | Flex容器的元素反向多行/列排布，子项允许超出容器。 |

**测试代码：**

```ts
import { NavItem } from './Demo02'

@Entry
@Component
struct Demo07 {
  @State rate: number = 0.7
  readonly imageList: NavItem [] = [
    { id: 1, icon: $r('app.media.ic_nav_01'), title: '淘金币' },
    { id: 2, icon: $r('app.media.ic_nav_02'), title: '摇现金' },
    { id: 3, icon: $r('app.media.ic_nav_03'), title: '闲鱼' },
    { id: 4, icon: $r('app.media.ic_nav_04'), title: '中通快递' },
    { id: 5, icon: $r('app.media.ic_nav_05'), title: '芭芭农场' },
    { id: 6, icon: $r('app.media.ic_nav_06'), title: '淘宝珍库' },
  ]

  // 底部滑块，可以通过拖拽滑块改变容器尺寸
  @Builder
  slider() {
    Slider({
      value: this.rate * 100,
      min: 10,
      max: 100,
      style: SliderStyle.OutSet
    })
      .blockColor(Color.White)
      .width('60%')
      .position({ x: '20%', y: '87%' })
      .onChange((value: number) => {
        this.rate = value / 100
      })
  }

  build() {
    Stack({ alignContent: Alignment.TopStart }) {
      Text('宽度:' + (this.rate * 100).toFixed(0) + '%')
        .zIndex(2)
        .translate({ x: 20, y: 20 })
        .fontColor(Color.Orange)
      Flex({ justifyContent: FlexAlign.Center, direction: FlexDirection.Column }) {
        Column() {
          // 布局能力 7：折行能力
          // 容器组件尺寸发生变化，当布局方向尺寸不足以显示完整内容时自动换行

          // 实现方式：
          // Flex组件将 wrp 设置为FlexWrap.Wrap即可


          // 通过Flex组件warp参数实现自适应折行
          Flex({
            direction: FlexDirection.Row,
            alignItems: ItemAlign.Center,
            justifyContent: FlexAlign.Center,
              wrap: FlexWrap.Wrap
          }) {
            ForEach(this.imageList, (item: NavItem) => {
              Column() {
                Image(item.icon)
                  .width(80)
                  .height(80)
                Text(item.title)
              }
              .margin(10)
            })
          }
          .backgroundColor(Color.Gray)
          .padding(20)
          .width(this.rate * 100 + '%')
          .borderRadius(16)

        }
        .width('100%')

        this.slider()
      }
      .width('100%')
      .height('100%')
      .backgroundColor('#F1F3F5')
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    }
  }
}
```



### 3.1.8. 小结

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717641177153-046590d2-b3ec-4bec-a920-4d4d51d9bffb.png)

参考的话术：

什么是一多开发?

- 鸿蒙开发体系中, 主打的是1(HarmonyOS)+8(手机/平板/...)+N(其它的智能设备)
- 一套代码, 多端部署, 按需适配

一多开发要解决哪些问题?

- 界面级一多(界面的适配问题)

- - 自适应布局 (小范围布局)

- - - 拉伸/均分/占比/缩放/延伸/隐藏/折行

- - 响应式布局 (大的界面改变)

- - - 断点
    - 媒体查询

- 功能级一多(所有功能不可能在所有设备都使用

- - canIUse

- 工程级一多(项目的组织和管理)

- - 三层架构 + hsp

\-----------------------------------



1. 一多开发中，提供了 2 种能力实现页面适配: 

1. 1. 自适应布局：

1. 1. 1. 核心就是利用一些组件及属性实现适配效果
      2. 比如 layoutWeight实现占比，比如 aspectRatio可以实现缩放
      3. 隐藏可以用 displayPriority
      4. 一共有 **7** 个，一下子可能想不起来那么多，核心就是一些属性而已
      5. 只能解决小屏幕手机到大屏幕手机的适配

1. 1. 响应式布局
   2. 不同终端设备的变化需要使用响应式布局



## 3.2. 响应式布局

[响应式布局](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/responsive-layout-V5)

自适应布局可以保证窗口尺寸在【一定范围内变化】时，页面的显示是正常的。但是将窗口尺寸【变化较大】时（如窗口宽度从400vp变化为1000vp），仅仅依靠自适应布局可能出现**图片异常放大或页面内容稀疏、留白过多**等问题，此时就需要借助响应式布局能力调整页面结构。

响应式布局是指页面内的元素可以根据特定的特征（如**窗口宽度、屏幕方向**等）自动变化以适应外部容器变化的布局能力。

响应式布局中最常使用的特征是**窗口宽度**，可以将窗口宽度划分为不同的范围（下文中称为**断点**）。当窗口宽度从**一个断点变化到另一个断点时**，改变页面布局（如将页面内容从单列排布调整为双列排布甚至三列排布等）以获得更好的显示效果。



![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717126752256-54cb08f4-22b1-46b3-a67a-276bb0e78e0c.png)![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717126768338-f62ddbf3-c40c-4e34-b710-80c1621c3c5f.png)![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717126787299-0c041af2-e65d-448d-a87c-6ebd4162abb6.png) 



**三种响应式布局能力：**

| **响应式布局能力**                                           | **简介**                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [断点](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/responsive-layout.md#断点) | 将窗口宽度划分为不同的范围（即断点），监听窗口尺寸变化，当断点改变时同步调整页面布局。 |
| [媒体查询](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/responsive-layout.md#媒体查询) | 媒体查询支持监听窗口宽度、横竖屏、深浅色、设备类型等多种媒体特征，当媒体特征发生改变时同步调整页面布局。 |
| [栅格布局](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/responsive-layout.md#栅格布局) | 栅格组件将其所在的区域划分为有规律的多列，通过调整不同断点下的栅格组件的参数以及其子组件占据的列数等，实现不同的布局效果。 |

### 3.2.1. 断点

### 3.2.1. 断点

断点以应用窗口宽度为切入点，将应用窗口在宽度维度上分成了几个不同的区间即不同的断点，在不同的区间下，开发者可根据需要实现不同的页面布局效果。

| **断点名称** | **取值范围（****vp****）** | **设备**         |
| ------------ | -------------------------- | ---------------- |
| xs           | [0, 320）                  | 手表等超小屏     |
| sm           | [320, 600)                 | 手机竖屏         |
| md           | [600, 840)                 | 手机横屏，折叠屏 |
| lg           | [840, +∞)                  | 平板，2in1 设备  |

**tips:**

1. 不需要记住范围
2. 记住断点名称及设备的关系即可



系统提供了多种方法，**判断应用当前处于何种断点**，进而可以调整应用的布局。常见的监听断点变化的方法如下所示：

- 获取窗口对象并监听窗口尺寸变化（了解）
- 通过媒体查询监听应用窗口尺寸变化（**掌握**）
- 借助栅格组件能力监听不同断点的变化（**掌握**）

通过窗口对象，监听窗口尺寸变化（了解）

1. 在 EntryAbility 中添加监听

```ts
import window from '@ohos.window'
import display from '@ohos.display'
import UIAbility from '@ohos.app.ability.UIAbility'

export default class EntryAbility extends UIAbility {
  private windowObj?: window.Window
  private curBp: string = ''
  //...
  // 根据当前窗口尺寸更新断点
  private updateBreakpoint(windowWidth: number) :void{
    // 将长度的单位由px换算为vp
    let windowWidthVp = windowWidth / display.getDefaultDisplaySync().densityPixels
    let newBp: string = ''
    if (windowWidthVp < 320) {
      newBp = 'xs' // 超小屏
    } else if (windowWidthVp < 600) {
      newBp = 'sm' // 小屏
    } else if (windowWidthVp < 840) {
      newBp = 'md' // 中屏
    } else {
      newBp = 'lg' // 大屏
    }
    if (this.curBp !== newBp) {
      this.curBp = newBp
      // 使用状态变量记录当前断点值
      AppStorage.setOrCreate('currentBreakpoint', this.curBp)
    }
  }

  onWindowStageCreate(windowStage: window.WindowStage) :void{
    windowStage.getMainWindow().then((windowObj) => {
      this.windowObj = windowObj
      // 获取应用启动时的窗口尺寸
      this.updateBreakpoint(windowObj.getWindowProperties().windowRect.width)
      // 注册回调函数，监听窗口尺寸变化
      windowObj.on('windowSizeChange', (windowSize)=>{
        this.updateBreakpoint(windowSize.width)
      })
    });
   // ...
  }
   
  //...
}
```

1. 页面中使用断点信息

```arkts
@Entry
@Component
struct Index {
  @StorageProp('currentBreakpoint') curBp: string = 'sm'

  build() {
    Flex({justifyContent: FlexAlign.Center, alignItems: ItemAlign.Center}) {
      Text(this.curBp).fontSize(50).fontWeight(FontWeight.Medium)
    }
    .width('100%')
    .height('100%')
  }
}
```

注意:

调试要在真机或者模拟器上, 在预览器中无法监听



### 3.2.2. 媒体查询

[媒体查询](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-layout-development-media-query-V5)

媒体查询常用于下面两种场景：

1. 针对设备和应用的属性信息（比如显示区域、深浅色、分辨率），设计出相匹配的布局。
2. 当屏幕发生动态改变时（比如分屏、横竖屏切换），同步更新应用的页面布局。

相比于上一节演示的 通过窗口对象监听尺寸变化，媒体查询的功能会更为强大

#### 3.2.2.1. 核心用法

咱们分 2 个角度来看看如何使用媒体查询

1. 整合步骤（重要）

导入模块  --->  创建监听器  ---> 注册监听器  ---> 移除监听器

1. 调整媒体查询条件（了解）

```ts
// 1. 导入 模块
import { mediaquery } from '@kit.ArkUI'

// 2. 创建监听器 
const listenerXS: mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(0vp<=width<320vp)');
const listenerSM: mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(320vp<=width<600vp)');

// 3. 注册监听器
// 组件即将创建出来
aboutToAppear(): void {
  // 添加回调函数
  listenerXS.on('change', (res: mediaquery.MediaQueryResult) => {
    console.log('changeRes:', JSON.stringify(res))
    // 执行逻辑
  })
  listenerSM.on('change', (res: mediaquery.MediaQueryResult) => {
    console.log('changeRes:', JSON.stringify(res))
    // 执行逻辑
  })
}

// 4. 移除监听器
// 即将销毁
aboutToDisappear(): void {
  // 移除监听 避免性能浪费
  listenerXS.off('change')
  listenerSM.off('change')
}
```

注意:

写范围的时候不要省略小括号

试一试：

参考示例代码：完成 4 个断点的监听

| **断点名称** | **取值范围（****vp****）** | **设备**         |
| ------------ | -------------------------- | ---------------- |
| xs           | [0, 320）                  | 手表等超小屏     |
| sm           | [320, 600)                 | 手机竖屏         |
| md           | [600, 840)                 | 手机横屏，折叠屏 |
| lg           | [840, +∞)                  | 平板，2in1 设备  |

```typescript
// 1. 导入媒体查询模块
import { mediaquery } from '@kit.ArkUI'

// 2. 创建监听器
const listenerXS: mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(0vp<=width<320vp)')
const listenerSM: mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(320vp<=width<600vp)')
const listenerMD: mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(600vp<=width<840vp)')
const listenerLG: mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(840vp<=width)')


@Entry
@Component
struct Demo09 {
  @State breakPoint: string = ''
  @State bgColor: Color = Color.White

  aboutToAppear(): void {
    // 3. 注册监听器
    listenerXS.on('change', (res: mediaquery.MediaQueryResult)=>{
      // 尺寸符合要求则结果为true {"matches":true,"media":"(0vp<=width<320vp)"}
      // console.log('mkLog', JSON.stringify(res))
      if(res.matches){
        this.breakPoint = 'XS'
        this.bgColor = Color.Red
      }
    })
    listenerSM.on('change', (res: mediaquery.MediaQueryResult)=>{
      // console.log('mkLog', JSON.stringify(res))
      if(res.matches){
        this.breakPoint = 'SM'
        this.bgColor = Color.Green
      }
    })
    listenerMD.on('change', (res: mediaquery.MediaQueryResult)=>{
      // console.log('mkLog', JSON.stringify(res))
      if(res.matches){
        this.breakPoint = 'MD'
        this.bgColor = Color.Blue
      }
    })
    listenerLG.on('change', (res: mediaquery.MediaQueryResult)=>{
      // console.log('mkLog', JSON.stringify(res))
      if(res.matches){
        this.breakPoint = 'LG'
        this.bgColor = Color.Pink
      }
    })
  }

  aboutToDisappear(): void {
    // 4. 移除监听器
    listenerXS.off('change')
    listenerSM.off('change')
    listenerMD.off('change')
    listenerLG.off('change')
  }

  build() {
    RelativeContainer() {
      Text(this.breakPoint)
        .id('Demo09HelloWorld')
        .fontSize(20)
        .fontWeight(FontWeight.Bold)

        .alignRules({
          center: { anchor: '__container__', align: VerticalAlign.Center },
          middle: { anchor: '__container__', align: HorizontalAlign.Center }
        })
    }
    .height('100%')
    .width('100%')
    .expandSafeArea([SafeAreaType.SYSTEM])
    .backgroundColor(this.bgColor)
  }

}
```



#### 3.2.2.2. 使用查询结果

目前查询的内容只在当前页面可以使用，如果希望应用中任意位置都可以使用，咱们可以使用AppStorage 进行共享

**核心步骤：**

1. 事件中通过 AppStorage.set(key,value)的方式保存当前断点值
2. 需要使用的位置通过 AppStorage 来获取即可

```ts
// 添加回调函数
listenerXS.on('change', (res: mediaquery.MediaQueryResult) => {
  console.log('changeRes:', JSON.stringify(res))
  if (res.matches == true) {
    // this.currentBreakpoint = 'xs'
    AppStorage.set('currentBreakpoint', 'xs')
  }
})
// 组件中引入 AppStorage
@StorageProp('currentBreakpoint') currentBreakpoint: CurrentBreakpoint = 'xs'

// 在需要的位置使用 AppStorage 中保存的断点值
Text(this.currentBreakpoint)
// 1. 导入模块
import { mediaquery } from '@kit.ArkUI'

// 2. 创建监听器
const listenerXS: mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(0vp<=width<320vp)')
const listenerSM: mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(320vp<=width<600vp)')
const listenerMD: mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(600vp<=width<840vp)')
const listenerLG: mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(800vp<=width)')


@Entry
@Component
struct Index {
  // @State curBp: string = ''

  @StorageProp('currentBreakPoint') currentBreakPoint: string = 'sm'

  aboutToAppear(): void {
    listenerXS.on('change', (res: mediaquery.MediaQueryResult)=>{
      console.log('changeRes:', JSON.stringify(res))
        if(res.matches){
          // this.curBp = 'xs'
          AppStorage.set('currentBreakPoint', 'xs')
        }
    })

    listenerSM.on('change', (res: mediaquery.MediaQueryResult)=>{
      console.log('changeRes:', JSON.stringify(res))
      if(res.matches){
         // this.curBp = 'sm'
        AppStorage.set('currentBreakPoint', 'sm')
      }
    })

    listenerMD.on('change', (res: mediaquery.MediaQueryResult)=>{
      console.log('changeRes:', JSON.stringify(res))
      if(res.matches){
        // this.curBp = 'md'
        AppStorage.set('currentBreakPoint', 'md')
      }
    })

    listenerLG.on('change', (res: mediaquery.MediaQueryResult)=>{
      console.log('changeRes:', JSON.stringify(res))
      if(res.matches){
        // this.curBp = 'lg'
        AppStorage.set('currentBreakPoint', 'lg')
      }
    })
  }

  aboutToDisappear(): void {
    listenerXS.off('change')
    listenerSM.off('change')
    listenerMD.off('change')
    listenerLG.off('change')
  }


  build() {
    Column(){
      Text(this.currentBreakPoint).fontSize(50).fontWeight(FontWeight.Bold)
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }
}
```



试一试: 

1. 参考文档，增加深色模式查询

[深色模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-layout-development-media-query-V5#媒体查询条件)

```typescript
// 1. 引入模块
import { mediaquery } from '@kit.ArkUI'

// 2. 创建监听器
const listenerDark: mediaquery.MediaQueryListener = mediaquery.matchMediaSync('(dark-mode: true)')

@Entry
@Component
struct Demo09 {
  @State message: string = '';

  aboutToAppear(): void {
    // 3. 注册监听器
    listenerDark.on('change', (res: mediaquery.MediaQueryResult)=>{
      console.log('深色模式', JSON.stringify(res))
      this.message = res.matches ? '深色模式' : '亮色模式'
    })
  }

  // 4. 移除监听器
  aboutToDisappear(): void {
    listenerDark.off('change')
  }

  build() {
    RelativeContainer() {
      Text(this.message)
        .id('Demo09HelloWorld')
        .fontSize(50)
        .fontWeight(FontWeight.Bold)
        .alignRules({
          center: { anchor: '__container__', align: VerticalAlign.Center },
          middle: { anchor: '__container__', align: HorizontalAlign.Center }
        })
    }
    .height('100%')
    .width('100%')
  }
}
```

#### 3.2.2.3. 系统工具-BreakpointSystem

[媒体查询](https://docs.openharmony.cn/pages/v4.1/zh-cn/application-dev/key-features/multi-device-app-dev/responsive-layout.md#媒体查询)

了解了媒体查询的核心语法之后，咱们来看看一个 媒体查询监听断点的小工具，这个工具是基于官方代码调整而来





**工具代码：**

```ts
import { mediaquery } from '@kit.ArkUI'

interface Breakpoint {
  name: string
  size: number
  mediaQueryListener?: mediaquery.MediaQueryListener
}

export const BreakpointKey: string = 'currentBreakpoint'

export class BreakpointSystem {
  private currentBreakpoint: string = 'md'
  private breakpoints: Breakpoint[] = [
    { name: 'xs', size: 0 }, { name: 'sm', size: 320 },
    { name: 'md', size: 600 }, { name: 'lg', size: 840 }
  ]

  public register() {
    this.breakpoints.forEach((breakpoint: Breakpoint, index) => {
      let condition: string
      if (index === this.breakpoints.length - 1) {
        condition = '(' + breakpoint.size + 'vp<=width' + ')'
      } else {
        condition = '(' + breakpoint.size + 'vp<=width<' + this.breakpoints[index + 1].size + 'vp)'
      }
      console.log(condition)
      breakpoint.mediaQueryListener = mediaquery.matchMediaSync(condition)
      breakpoint.mediaQueryListener.on('change', (mediaQueryResult) => {
        if (mediaQueryResult.matches) {
          this.updateCurrentBreakpoint(breakpoint.name)
        }
      })
    })
  }

  public unregister() {
    this.breakpoints.forEach((breakpoint: Breakpoint) => {
      if (breakpoint.mediaQueryListener) {
        breakpoint.mediaQueryListener.off('change')
      }
    })
  }

  private updateCurrentBreakpoint(breakpoint: string) {
    if (this.currentBreakpoint !== breakpoint) {
      this.currentBreakpoint = breakpoint
      AppStorage.set<string>(BreakpointKey, this.currentBreakpoint)
      console.log('on current breakpoint: ' + this.currentBreakpoint)
    }
  }
}
```

**核心用法：**

1. 导入 BreakpointSystem
2. 实例化BreakpointSystem
3. aboutToAppear中注册监听事件 aboutToDisappear中移除监听事件
4. 通过 AppStorage，结合 获取断点值即可

```ts
// 1. 导入断点查询类
import { BreakpointSystem, BreakpointKey} from '../common/BreakpointSystem'

@Entry
@Component
struct Demo10 {

  // 5. 获取断点值
  @StorageProp(BreakpointKey) currentBreakpoint: string = 'sm'

  // 2. 实例化断点查询类
  breakpointSystem = new BreakpointSystem()

  // 3. 注册事件监听
  aboutToAppear(): void {
    this.breakpointSystem.register()
  }

  // 4. 移除事件监听
  aboutToDisappear(): void {
    this.breakpointSystem.unregister()
  }

  build() {
    RelativeContainer() {
      Text(this.currentBreakpoint)
        .id('Demo10HelloWorld')
        .fontSize(50)
        .fontWeight(FontWeight.Bold)
        .alignRules({
          center: { anchor: '__container__', align: VerticalAlign.Center },
          middle: { anchor: '__container__', align: HorizontalAlign.Center }
        })
    }
    .height('100%')
    .width('100%')
  }
}
```



**试一试：**

1. 测试 BreakpointSystem工具的使用
2. 测试根据断点调整页面结构，比如颜色，比如图片
3. 考虑 2 种情况即可，比如：

1. 1. md 为红色，其他为绿色
   2. sm 为图片 A，其他为图片 B
   3. ...

#### 3.2.2.4. 系统工具-BreakPointType

上一节演示的工具可以方便的监听屏幕处于哪个断点范围，咱们可以根据断点调整页面：

1. 如果是 2 个的情况：用 3 元即可
2. 如果是 多个的情况：用 3 元就不太方便啦

咱们再来看一个系统提供的工具BreakPointType

下面这份代码可以拷贝到 BreakpointSystem.ets中，他们本来就是在一起的

```ts
/*
 定义一个接口类型
 键: 断点值
 值: 泛型
*/
declare interface BreakPointTypeOption<T> {
  xs?: T
  sm?: T
  md?: T
  lg?: T
  xl?: T
  xxl?: T
}

/*
 对外导出一个类
 在实例化的时候接收一个泛型
*/
export class BreakPointType<T> {
  // 选项对象
  options: BreakPointTypeOption<T>

  constructor(option: BreakPointTypeOption<T>) {
    this.options = option
  }

  getValue(currentBreakPoint: string) {
    if (currentBreakPoint === 'xs') {
      return this.options.xs
    } else if (currentBreakPoint === 'sm') {
      return this.options.sm
    } else if (currentBreakPoint === 'md') {
      return this.options.md
    } else if (currentBreakPoint === 'lg') {
      return this.options.lg
    } else if (currentBreakPoint === 'xl') {
      return this.options.xl
    } else if (currentBreakPoint === 'xxl') {
      return this.options.xxl
    } else {
      return undefined
    }
  }
}
```

**核心用法:**

需求:

xs: 红色, sm: 绿色, md: 蓝色, lg:粉色

```ts
// 1. 导入BreakPointType
import { BreakPointType } from 'xxx'

@entry
@Component
struct ComB {
  // 2. 通过 AppStorage 获取断点值
  @StorageProp('currentBreakpoint') currentBreakpoint: CurrentBreakpoint = 'xs'

  build() {
    Column() {
      Text(this.currentBreakpoint)
    }
    .width(200)
    .height(200)
    .backgroundColor(
      // 3. 实例化 设置不同断点的取值，并通过 getValue 根据当前断点值对应的值
      new BreakPointType({
        xs: Color.Red,
        sm: Color.Yellow,
        md: Color.Blue,
        lg: Color.Green
      }).getValue(this.currentBreakpoint)
    )
  }
}
```

#### 3.2.2.5. 案例-电影列表

使用刚刚学习的媒体查询工具，结合断点来完成一个案例效果

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717147240395-f0da0875-5f7b-4db5-8ebb-5c573f0ccc0b.png)

需求：

1. xs 及 sm 2 列
2. md：3 列
3. lg：4 列

自行拓展：

1. 设置不同的宽高
2. 设置不同的圆角尺寸
3. 设置不同的间隙
4. 。。。。

基础模版:

```ts
interface MovieItem {
  title: string
  img: ResourceStr
}

@Entry
@Component
struct Demo09_demo {
  items: MovieItem[] = [
    { title: '电影标题1', img: $r('app.media.ic_video_grid_1') },
    { title: '电影标题2', img: $r('app.media.ic_video_grid_2') },
    { title: '电影标题3', img: $r('app.media.ic_video_grid_3') },
    { title: '电影标题4', img: $r('app.media.ic_video_grid_4') },
    { title: '电影标题5', img: $r('app.media.ic_video_grid_5') },
    { title: '电影标题6', img: $r('app.media.ic_video_grid_6') },
    { title: '电影标题7', img: $r('app.media.ic_video_grid_7') },
    { title: '电影标题8', img: $r('app.media.ic_video_grid_8') },
    { title: '电影标题9', img: $r('app.media.ic_video_grid_9') },
    { title: '电影标题10', img: $r('app.media.ic_video_grid_10') },
  ]

  build() {
    Grid() {
      ForEach(this.items, (item: MovieItem) => {
        GridItem() {
          Column({ space: 10 }) {
            Image(item.img)
              .borderRadius(10)
            Text(item.title)
              .width('100%')
              .fontSize(20)
              .fontWeight(600)

          }
        }
      })
    }
    .columnsTemplate('1fr 1fr')
    .rowsGap(10)
    .columnsGap(10)
    .padding(10)
  }
}
```

**参考代码:**

```ts
import { BreakPointType, BreakpointSystem, BreakpointKey } from '../../common/breakpointsystem'

interface MovieItem {
  title: string
  img: ResourceStr
}

@Entry
@Component
struct Demo09_demo {
  items: MovieItem[] = [
    { title: '电影标题1', img: $r('app.media.ic_video_grid_1') },
    { title: '电影标题2', img: $r('app.media.ic_video_grid_2') },
    { title: '电影标题3', img: $r('app.media.ic_video_grid_3') },
    { title: '电影标题4', img: $r('app.media.ic_video_grid_4') },
    { title: '电影标题5', img: $r('app.media.ic_video_grid_5') },
    { title: '电影标题6', img: $r('app.media.ic_video_grid_6') },
    { title: '电影标题7', img: $r('app.media.ic_video_grid_7') },
    { title: '电影标题8', img: $r('app.media.ic_video_grid_8') },
    { title: '电影标题9', img: $r('app.media.ic_video_grid_9') },
    { title: '电影标题10', img: $r('app.media.ic_video_grid_10') },
  ]
  breakpointSystem: BreakpointSystem = new BreakpointSystem()
  @StorageProp(BreakpointKey)
  currentBreakpoint: string = 'sm'

  aboutToAppear(): void {
    this.breakpointSystem.register()
  }

  aboutToDisappear(): void {
    this.breakpointSystem.unregister()
  }

  build() {
    Grid() {
      ForEach(this.items, (item: MovieItem) => {
        GridItem() {
          Column({ space: 10 }) {
            Image(item.img)
              .borderRadius(10)
            Text(item.title)
              .width('100%')
              .fontSize(20)
              .fontWeight(600)

          }
        }
      })
    }
    .columnsTemplate(new BreakPointType({
      xs: '1fr 1fr',
      sm: '1fr 1fr ',
      md: '1fr 1fr 1fr ',
      lg: '1fr 1fr 1fr 1fr '
    }).getValue(this.currentBreakpoint))
    .rowsGap(10)
    .columnsGap(10)
    .padding(10)
  }
}
```

### 3.2.3. 栅格布局 Grid

栅格组件的本质是：将组件划分为有规律的多列，通过调整【不同断点】下的【栅格组件的列数】，及【子组件所占列数】实现不同布局

**比如：**

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717143778061-d08eb988-fb9f-4c6d-8624-425c35bb0501.png)

**参考栅格列数设置:**

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717143842237-f90a5bdb-e220-418c-a8ba-630cd519b718.png)

#### 3.2.3.1. 核心用法

```arkts
// 行
GridRow(属性){
  // 列
  GridCol(属性){
    
  }
}
```

**测试代码:**

优先级从上往下：

1. GridRow breakpoints属性 和 的 onBreakpointChange 事件（了解）
2. GridRow的 columns 属性、GridCol 的 span 属性（掌握）
3. GridRow 的 gutter属性、GridCol 的 offset 属性（掌握）

```typescript
@Entry
@Component
struct Demo12 {
  @State currentBreakPoint: string = 'sm'

  build() {
    Column() {
      // GridRow 默认支持 4 个断点
      //  xs:(0vp<=width<320vp) 智能穿戴，比如手表
      //  sm:(320vp<=width<600vp) 手机
      //  md:(600vp<=width<840vp) 折叠屏
      //  lg:(840vp<=width) 平板
      GridRow() {
        ForEach(Array.from({ length: 12 }), (item: string, index: number) => {
          GridCol() {
            Text(index.toString())
          }
          .height(100)
          .border({ width: 1, color: Color.Black })
        })
      }
      .width('90%')
      .height('90%')
      .border({ width: 1, color: Color.Orange })

      Text(`断点值: ${this.currentBreakPoint}`)
        .fontSize(30)
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#dcdfe8')
    .expandSafeArea([SafeAreaType.SYSTEM])
  }
}
@Entry
@Component
struct Demo12 {
  @State currentBreakPoint: string = ''

  build() {
    Column() {
      // GridRow 默认支持 4 个断点
      //  xs:(0vp<=width<320vp) 智能穿戴，比如手表
      //  sm:(320vp<=width<600vp) 手机
      //  md:(600vp<=width<840vp) 折叠屏
      //  lg:(840vp<=width) 平板
      GridRow({
        breakpoints: {
          value: ['320vp', '600vp', '840vp']
        },
        gutter: 10, // 子项之间的间距  {x:?  ,y:?}
        // columns: 12, // 设置一行的总列数, 默认: 一行12列
        // 可以根据断点值, 设置每一行的列数
        columns: {
          xs: 2, // 超小屏, 比如: 手表
          sm: 4, // 小屏幕, 比如: 手机竖屏
          md: 8, // 中等屏幕, 比如: 折叠屏, 手机横屏
          lg: 12, // 大屏幕, 比如: pad
        }
      }) {
        ForEach(Array.from({ length: 2 }), (item: string, index: number) => {
          GridCol({
            // 设置一列占得份数
            // span: 2,
            // 支持不同断点分别设置不同的占用列数
            span: {
              xs: 1,
              sm: 1,
              md: 1,
              lg: 1
            },
            // offset 偏移列数 默认为 0
            // offset: 1, // 偏移一列
            // 支持不同断点分别设置偏移不同的列数
            offset: {
              sm: 1
            }
          }) {
            Text(index.toString())
          }
          .height(100)
          .border({ width: 1, color: Color.Black })
        })
      }
      .width('90%')
      .height('90%')
      .border({ width: 1, color: Color.Orange })
      // 断点发生变化时触发回调
      .onBreakpointChange((breakPoint) => {
        console.log('breakPoint', breakPoint)
        this.currentBreakPoint = breakPoint
      })

      Text(`断点值: ${this.currentBreakPoint}`)
        .fontSize(30)
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#dcdfe8')
  }
}
```



#### 3.2.3.2. 案例-登录界面

结合咱们刚刚学习的 栅格布局。来实现如下效果

![img](https://cdn.nlark.com/yuque/0/2024/png/639379/1717147470593-8c9191c6-df26-46fc-a6f2-4a6983318109.png)

需求:

1. sm：4列，占 4 列
2. md：8 列，占 6 列，偏移 1
3. lg: 12 列，占 8 列，偏移 2

**基础模版：**

```ts
@Entry
@Component
struct Demo14 {
  build() {
    Stack() {
      // 辅助用的栅格（顶层粉色区域）
      GridRow({ gutter: 10, columns: { sm: 4, md: 8, lg: 12 } }) {
        ForEach(Array.from({ length: 12 }), () => {
          GridCol()
            .width('100%')
            .height('100%')
            .backgroundColor('#baffa2b4')
        })
      }
      .zIndex(2)
      .height('100%')

      //  内容区域
      GridRow({
        // TODO 分别设置不同断点的 列数

      }) {
        // 列
        GridCol({
          // TODO 分别设置不同断点的 所占列数

          // TODO 分别设置不同断点的 偏移


        }) {
          Column() {
            // logo+文字
            LogoCom()

            // 输入框 + 底部提示文本
            InputCom()

            // 登录+注册账号按钮
            ButtonCom()

          }
        }
      }
      .width('100%')
      .height('100%')
      .backgroundColor('#ebf0f2')
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    }
  }
}

@Component
struct LogoCom {
  build() {
    Column({ space: 5 }) {
      Image($r('app.media.ic_logo'))
        .width(80)
      Text('登录界面')
        .fontSize(23)
        .fontWeight(900)
      Text('登录账号以使用更多服务')
        .fontColor(Color.Gray)
    }
    .margin({ top: 100 })
  }
}

@Component
struct InputCom {
  build() {
    Column() {
      Column() {
        TextInput({ placeholder: '账号' })
          .backgroundColor(Color.Transparent)
        Divider()
          .color(Color.Gray)
        TextInput({ placeholder: '密码' })
          .type(InputType.Password)
          .backgroundColor(Color.Transparent)

      }
      .backgroundColor(Color.White)
      .borderRadius(20)
      .padding({ top: 10, bottom: 10 })

      Row() {
        Text('短信验证码登录')
          .fontColor('#006af7')
          .fontSize(14)
        Text('忘记密码')
          .fontColor('#006af7')
          .fontSize(14)
      }
      .width('100%')
      .justifyContent(FlexAlign.SpaceBetween)
      .margin({ top: 10 })

    }
    .padding(5)
    .margin({ top: 80 })

  }
}

@Component
struct ButtonCom {
  build() {
    Column({ space: 10 }) {
      Button('登录')
        .width('90%')
      Text('注册账号')
        .fontColor('#006af7')
        .fontSize(16)
    }
    .margin({ top: 60 })
  }
}
```

参考代码

```ts
@Entry
@Component
struct Demo11_login {
  build() {
    Stack() {
      // 辅助用的栅格（顶层粉色区域）
      GridRow({ gutter: 10, columns: { sm: 4, md: 8, lg: 12 } }) {
        ForEach(Array.from({ length: 12 }), () => {
          GridCol()
            .width('100%')
            .height('100%')
            .backgroundColor('#baffa2b4')
        })
      }
      .zIndex(2)
      .height('100%')

      //  内容区域
      GridRow({
        // TODO 分别设置不同断点的 列数
        columns: {
          sm: 4,
          md: 8,
          lg: 12
        }
      }) {
        // 列
        GridCol({
          // TODO 分别设置不同断点的 所占列数
          span: {
            sm: 4,
            md: 6,
            lg: 8
          },
          // TODO 分别设置不同断点的 偏移
          offset: {
            md: 1,
            lg: 2
          }

        }) {
          Column() {
            // logo+文字
            LogoCom()

            // 输入框 + 底部提示文本
            InputCom()

            // 登录+注册账号按钮
            ButtonCom()

          }
        }
      }
      .width('100%')
      .height('100%')
      .backgroundColor('#ebf0f2')
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM])
    }
  }
}

@Component
struct LogoCom {
  build() {
    Column({ space: 5 }) {
      Image($r('app.media.ic_logo'))
        .width(80)
      Text('登录界面')
        .fontSize(23)
        .fontWeight(900)
      Text('登录账号以使用更多服务')
        .fontColor(Color.Gray)
    }
    .margin({ top: 100 })
  }
}

@Component
struct InputCom {
  build() {
    Column() {
      Column() {
        TextInput({ placeholder: '账号' })
          .backgroundColor(Color.Transparent)
        Divider()
          .color(Color.Gray)
        TextInput({ placeholder: '密码' })
          .type(InputType.Password)
          .backgroundColor(Color.Transparent)

      }
      .backgroundColor(Color.White)
      .borderRadius(20)
      .padding({ top: 10, bottom: 10 })

      Row() {
        Text('短信验证码登录')
          .fontColor('#006af7')
          .fontSize(14)
        Text('忘记密码')
          .fontColor('#006af7')
          .fontSize(14)
      }
      .width('100%')
      .justifyContent(FlexAlign.SpaceBetween)
      .margin({ top: 10 })

    }
    .padding(5)
    .margin({ top: 80 })

  }
}

@Component
struct ButtonCom {
  build() {
    Column({ space: 10 }) {
      Button('登录')
        .width('90%')
      Text('注册账号')
        .fontColor('#006af7')
        .fontSize(16)
    }
    .margin({ top: 60 })
  }
}
```



